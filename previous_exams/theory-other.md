### 1. Неформални описания за операционната система

Софтуерът, който организира работата на дадена изчислителна система. Целта ѝ е да я поддържа и да ѝ даде възможно най-много функционалности, възможности за работа.	 	

- 1.1. Посредник между агентите, ползващи изчислителната система


 Файловете; драйверите; логическото устройство (операционната система) представляват посредници между агентите използващи изчислителната система


- 1.2. Управител на ресурси
Можем да кажем, че операционната система играе ролята на управител на ресурсите на изчислителната система и удобното им представяне за различните агенти (хора, програми и т.н.). 


	Операционната система трябва ефективно да управлява ресурсите на машината, като ги разпределя между много програми и потребители, състезаващи се за правото да ги използват. Например, ако няколко програми(процеса) се опитат едновременно да извеждат на едно и също печатащо устройство. Какво ще се случи? ОС трябва да осигури използването на този ресурс по такъв начин, че едновременно изпълняваните програми да не си пречат. Многопотребителската ОС поддържа едновременна работа на няколко потребителя. Тогава управлението на ресурсите става още по-важна функция, защото последователността, в която различните потребители ще използват ресурсите е непредсказуема. ОС трябва да решава от кого да се използва определен ресурс при наличие на няколко заявки за него, т.е. да разпределя ресурсите. Сложността на тази задача идва от там, че ресурсите са различни от гледна точка на възможностите за съвместното им използване. Кои са ресурсите? Това са процесор, оперативна памет, входно-изходни устройства.
- 1.3. Среда,осигуряваща стандарти и инструменти за комуникация между агентите на ИС


	Една от първите услуги, които възникват като част от ранните операционни системи, е да се направят единни инструменти за работа с хардуера или поне за цели класове устройства - четене/писане върху магнитна лента, работа с диск. Този тип дейност наричаме абстрахиране на хардуера - т.е. заменяне на реалния хардуер с друго, виртуално устройство, което веднъж да е добре дефинирано и да ползваме само него, а самата работа с хардуера да я върши софтуер, който вече имаме и е част от операционната система.

### 2. Основни абстракции

- 2.1.Файл - oбособен масив от байтове, който си има име и може да бъде достъпен от другите агенти в системата. Загубеният файл не съществува.;

Осигурява унифицирани операции за вход и изход, т.е. операции, които не зависят от входно-изходните устройства, съхраняващи данните.
Файловата система представлява съвкупност от файлове и информация, която описва определени характеристики на всеки от тях. Целта на файловата система е да позволи подредба на файловете с цел по-лесно откриване. Има много файлови системи — те се различават по начина, по който се осъществява подредбата на файловете и по допълнителните характеристики, които се пазят за всеки файл. Тези характеристики могат да включват вид, права за достъп, размер, дата на последна промяна и др. Файловите системи обикновено подреждат файловете в структура, наречена Файлово дърво. Има различни файлове според функциите си във файловата система. Съвременните файлови системи поддържат съотвествие кой е собственика, кой има права на достъп до файла(права и привилегии).

- 2.2.Процес

	В операционните системи понятието процес е централно, всичко останало, включително и абстракцията файл, се гради върху него. Съвременните компютри са способни да изпълняват няколко операции едновременно. Докато централния процесор (ЦП) изпълнява команди, дисковото устройство може да чете и терминалът или принтерът да извеждат данни.

- 2.3.Комуникационни канали

За да може процесите да си комуникират помежду си, те използват операционната система като главен канал за тази връзка. Използват се за да се доберем до други ресурси извън локалното простанство. Самият канал е мястото, което е достъпно за двата процеса.

- 2.4. Имена - осъществяването на връзка(адресация) между обекти, ресурсите трябва да бъдат именувани.


Файлов дескриптор - Неотрицателно цяло число, което служи за уникален идентификатор на отворен файл. При отваряне на файл, ядрото извършва необходимите действия за отваряне на файла, зарежда информация за него. След това връща файловия дескриптор, който се свързва с отворения файл, ползва се в програмата, а след затваряне се освобождава. Дескрипторът има локално значение - връзката между дескриптор (число) и отворен файл важи само за текущия процес.

- 2.5.Хардуерните абстракции


Харудерните абстракции често позволяват на програмистите да пишат приложения, които са устройство-независими и са високо-производителни. Това става като се правят стандартни извиквания от операционната система към хардуера.

- 2.6.Приложно-програмният интерфейс

Приложно-програмният интерфейс e интерфейсът на изходния код, който операционната система или нейните библиотеки от ниско ниво предлагат за поддръжката на заявките от приложния софтуер или компютърните програми.
Образно казано, приложно-програмният интерфейс предоставя един по-абстрактен и опростен план за разработчика на приложения, който би му спестил изучаването на няколко различни слоя от Операционната или софтуерната система зад интерфейса. По този начин се достига ефективност и бързина при адаптирането на нови софтуерни технологии. В миналото терминът се е използвал за обозначението на интерфейса между две програми.

### 3. Разпределено ползване на ресурсите

- 3.1. Разпределяне на ресурса на части

	Ресурса е споделен или мултиплексиран между потребителите. Това може да е времево-мултиплексиране(потребителите се редуват) или място-мултиплексиране(всеки потребител получава част от ресурса)

- 3.2. Разпределяне във времето

Програмите или потребителите (всъщност процесите) използват ресурса последователно една след друга. Задачата на ОС е да решава: Кой да е следващия? Колко дълго да го използва? Да отнема ли насилствено предоставен ресурс? Когато ОС насилствено отнема ресурс от процес, казваме че има преразпределяне. Пример за разпределяни по този начин са:
Централен процесор – обикновено с преразпределяне;
Печатащо устройство – обикновено без преразпределяне.

- 3.3. Разпределяне в пространството

Ресура се разделя на части и всяка програма или потребител получава част от него. Проблемите, които ОС трябва да решава са следните: Да следи свободните и заети части. Да осигури защита на частите. Справедливо да разделя ресура. Ресурси,управлявани по този начин, са оперативна памет и дискова памет.

### 4. Видове ОС по начина на разделяне на изолация на ресурсите

- 4.1. Еднозадачна, еднопотребителска ОС

Еднозадачната ОС изпълнява само една задача в даден момент. Еднопотребителските ОС не различават потребителите, но не са непременно еднозадачни, тъй като няколко програми могат да се изпълняват в съчетание. Например MS DOS е еднопотребителска еднозадачна ОС.

- 4.2. Многозадачна ОС

Многозадачната изпълнява няколко задачи едновременно. Това се постига чрез разделение на времето на работа на процесора според инструкциите на специална подсистема (task scheduling subsystem). при разпределена многозадачност (pre-emptive multitasking) ОС отпуска на задачата определено време да ползва процесора. Ако тя не успее да приключи за това време, ОС я форсира да отстъпи процесора на следващата задача, която се нуждае от него. Такива ОС са Unix-базираните като Solaris, Linux.
 При кооперативната многозадачност приложението, стартирано от ОС, използва 100% от процесора. В този случай, ако друга програма изиска процесорно време, то или няма да ѝ бъде предоставено, което ще доведе до нарушаване на функциите на това приложение и/или до терминирането му, или ще бъде предоставено след приключване на първото – такива са 16-битовите версии на Microsoft Windows.

- 4.3. Времеделене

Тъй като скоростта на въвеждането на данни от оператор е много по-ниска от скоростта на обработка на същите данни от процесора, използването на компютъра от само един оператор води до прахосване на скъпи изчислителни ресурси. „Разделението по време“ (time sharing) позволява създаването на многопотребителски системи, в които централният процесор и блокът на оперативната памет обслужват много потребители. При това част от задачите (като въвеждане или редактиране на данни) могат да се изпълняват в диалогов режим чрез терминали, а други (като обемните изчисления) – в пакетен режим.

- 4.4. Многопотребителска ОС

Многопотребителските ОС разширяват концепцията за многозадачност, като различават потребителите по отношение ползването на процеси и ресурси, като например дисково пространство. Те планират ефикасното използване на ресурсите на системата и могат да съдържат специализиран софтуер за изчисление на процесорното време от много потребители, както и да отчитат използваната памет, ползване на принтер и други използвани ресурси.

### 5. Комуникация и общо ползване на ресурс

- 5.1. Съревнование на ресурси (race condition)

Съревнованието на ресурси е поведението, при което изхода е зависим от последователнноста или тайминга от други неконтролируеми събития.(когато два сигнала се състезават помежду си за да достигнат изхода първи);
Когато няколко процеса работят с един и същ ресурс по едно и също време. 

- 5.1.1. Критична секция, атомарна обработка на ресурса

Тази част от програмата, в която се осъществява достъп до обща памет или се вършат неща, които могат да доведат до състезание се нарича критичен участък. Процесът е започнал и не е завършил изпълнението му, независимо от състоянието си. 

Условия за избягване на състезанието:

                     - 1.В един момент най-много един процес може да се намира в критичния си участък.
                     - 2.Никой процес да не остава в критичния си участък безкрайно дълго.
                     - 3.Никой процес, намиращ се вън от критичния си участък, да не пречи на друг процес да влезе в своя критичен участък.
                     - 4.Решението не бива да се основава на предположения за относителните скорости на процесите.

- 5.1.2. Защита на ресурса

Когато няколко процеса работят с един и същ ресурс по едно и също време. Решение - обединяване на инструкциите на двата процеса в една единствена инструкция.

При еднопроцесорите машини това става сравнително лесно - временно се спират прекъсванията (докато се изпълни дадената инструкция докрай и да се постигне атомарност).

Друго решение (значително по-добро) е да се осигурят инструменти за защита на структурата данни. Например като към всяка такава структура добавим специален бит, който да показва дали е свободна, или не. Когато даден процес иска да работи с нея, първо проверява дали е свободна. Ако не е, изчаква, а ако е - запазва я и като приключи работата си с нея я освобождава.

- 5.1.3. Наредба във времето на процесите,ползващи ресурса

Непредсказуемо е времето,в което ще се изпълнят процесите.

- 5.2. Хардуерни инструменти за защита (lock) на ресурса

- 5.2.1. Enable/disable interrupt за еднопроцесорна система

Самите процедури за обработка на структурата да им осигурим изпълнението като единна инструкция неделима във времето. Инстукрцията блокира временно прекъсванията. Когато се влезе в режим на работата в ядрото, кода извиква процедура от ядрото да го изпълни и може да се сложи в опашката инструкция да спре и да пусне прекъсванията.
При еднопроцесорните системи се постига взаимно изключване просто като се изключат прекъсванията в критичния участък

- 5.2.2. test and set

Тази инструкция се използва, за да се пише в паметта и да се върне старата стойност като атомарна операция. ЦП може да използва test-and-set инструкция предложена от друг компонент,напривем двупортор RAM; ЦП може също да предложи test-and-set инструкция.

- 5.2.3. atomic swap

Атомарната инструкция се използва да се постигне синхронизация. Тя сравнява съдържанието на локация в паметта с дадена стойност и само ако са същите,модифицира съдържанието с новата стойност. Това е направено като единична атомарна операция.

- 5.3. Spinlock

Spinlock е ключ, който кара нишката,която се опитва да го вземе, да изчаква в цикъл,проверявайки постоянно дали ключа е свободен. Тъй като нишката остава активна, но не извърша смислена задача,това се нарича активно чакане.

### 6. Синхронизация от високо ниво - семафор

Когато два процеса си комуникират, те обикновено използват обща памет. При използването на обща памет се появява проблемът с надпреварата за ресурси (т.е. ако двата процеса използват паметта по едно и също време, те могат да развалят консистентността на информацията, съхранявана в нея). За да се реши този проблем, в съвременните операционни системи, зоните, в които тези процеси си комуникират, са изолирани от процеса и са предоставени на ядрото на операционната система. Например, работата по обслужването на тръбите (pipes) се извършва изцяло от ядрото.
Подобен проблем възниква и в многонишковото програмиране (когато към даден процес, предоставен от операционната система, паралелно се извършват няколко подпроцеса, които се налага да си комуникират помежду си). Друг случай, в който се използват общи ресурси и трябва да се синхронизира работата на програмите, е при базите от данни. При тях също се случва едновременно да работят няколко процеса, които да искат да достъпват и променят едно и също парче памет.

Когато опашката е опашка в обикновения смисъл (винаги елементи се взимат отпред, а новите се слагат отзад), тогава семафорът е силен (събуждането е в реда на заспиването). Слаб семафор е семафор, при който не е определен редът на събуждането. При него, ако има дълга опашка от заспали процеси, може да възникне "livelock" (процес, който е в операционната система, но не напредва своята работа - приспан е, чака някой да го събуди, но никой не го събужда) или "starvation" (процесът постоянно чака да му се дадат ресурси, но не му се дават и той гладува).

- 6.1 Приспиване и събуждане на процеси (block/ wakeup)

Операцията P проверява и намалява значението на брояча на семафора, ако това е възможно, в противен случай блокира процеса и го добавя в списъка на чакащи процеси, свързан със съответния семафор. Събитието, което блокирания процес чака, е увеличение на брояча на семафора. Това събитие ще настъпи когато друг процес изпълни операцията V над същия семафор. Операцията V събужда един блокиран по семафора процес, ако има такива, а в противен случай увеличава брояча на семафора, т.е. запомня едно събуждане. За операциите P и V се използва и обозначението down и up.

- 6.2 Семафор - дефиниция

Структура от данни, която е много полезна и приложима при решаването на синхронизационни въпроси. 
Семафорът е като целочислена променлива S, приемаща само неотрицателни стойности, за която са достъпни две операции:
P(S) - Ако S>0, то S=S-1, иначе процесът, който изпълнява операцията се блокира.
V(S) - Ако има процеси, блокирани по семафора S, то един от тях се освобождава, иначе S=S+1.

Когато нишка намалява стойността на семафора , ако семафора е отрицателен нишката блокира и не може да продължи докато друга нишка не увеличи семафора 
Ако стойността на семафора е отрицателна и една нишка го увеличи , някоя от блокиралите нишки се събужда 

Когато стойността на семафора е положителна, това значи колко нишки могат да го намалят преди да блокират , когато е отрицателна - колко нишки са блокирани , когато е 0 - няма нишки ,които чакат(няма заспали нишки) и ако нишка се опита да го намали ще го блокира

- 6.3 Реализация
- 6.4 Семафор като охранител на бариера (ресурс)

Бариера, синхронизираща два процеса:никой процес не може да мине след бариерата докато и двата не стигнат до нея. С всеки процес се свързва синхронизационен флаг, който се реализира със семафор.

### 7. Прости задачи за синхрозация чрез семафори:

### 8. Още задачи за синхронизация чрез семафори: 

- 8.1 Pipe 

Програмният канал осигурява еднопосочно предаване на неформатиран поток от данни (поток от байтове) между процеси и синхронизация на работата им. Реализира се като тип файл, който се различава от обикновените файлове и има следните особености:

                     - За четене и писане в него се използват системните примитиви read и write, но дисциплината е FIFO.
                     - Каналът има доста ограничен капацитет.

- 8.2 Pipe с буфер - тръба съхраняваща n пакета информация. Използване на семафорите като броячи на свободни ресурси.

Пример: Програмата, която изпраща данни може да произвежда 5000 байта за секунда, а програмата която получава данни може да приема само 100 байта за секунда, но никаква информация не се губи. Информацията изпратена от изпращача се пази в буфер,който има определен размер. Когато програмата, която чете данни е готова за приемане ,започва да  чете от буфера.

### 9. Проблеми при некоректна синхронизация:

- 9.1 DeadLock (Взаимно блокиране) 

Казваме, че множество от два или повече процеса са в дедлок (deadlock), ако всички те са в състояние блокиран и всеки чака настъпването на събитие, което може да бъде предизвикано само от друг процес в множеството. Тъй като всички процеси са блокирани, никой от тях не може да работи и да предизвика събитие, което да събуди някой друг процес от множеството. Следователно, ако системата не се намеси, всички процеси ще останат вечно блокирани. Събитието, което процесите чакат най-често е предоставяне на ресурс на системата.

- 9.2 Livelock, resource starvation ( Гладуване )

Този проблем се появява когато на процес не му бъде доставен достъп до нужните ресурси, без които този процес никога няма да може да завърши своята работа. Обикновено гладът е причинен от прилагането на твърде опростен алгоритъм за съставяне на разписания по които процесите се изпълняват. Този алгоритъм, който е част от ядрото (kernel), би трябвало да предоставя еднакво ресурси за всеки един от процесите, тъй че нито един от процесите в разписанието или разписанията да не остава без нужните ресурси.
Livelock е подобно на deadlock,обаче с разликата че състоянията на процесите,които участват в livelock-а постоянно се променят 1 с друг, като никой не прогресира.

- 9.3 Пример: задача за философите

Пет философа седят около кръгла маса, като пред всеки от тях има чиния със спагети, а между всеки две чинии има само по една вилица. Животът на всеки философ представлява цикъл, в който той размишлява, в резултат на което огладнява и се опитва да вземе двете вилици около своята чиния. Ако успее, известно време се храни, а след това връща вилиците.

Решение на задачата с философите - първо всички взимат дясната вилица. При опит да вземат и лявата, виждат, че е заета и оставят и дясната. След случайно време правят нов опит - взимат дясната и опитват да вземат и лявата. Ако е свободна, започват да ядат, ако не е - изчакват отново случайно време. Това решение предотвратява deadlock-a, но може да доведе до starvation.
Друго решение е общите ресурси да бъдат номерирани и когато трябва да вземем няколко ресурса, всеки процес да ги взима в нарастващ ред. Това решение също не гарантира, че няма да се получи starvation. Също така не работи в случаите, когато не знаем отначало точно кои ресурси ще ни трябват, а разбираме постепенно в процеса на работа. Тогава се прилагат други техники.

### 10. Процеси и тяхното управление:

Състоянията изразяват моментната необходимост на процеса спрямо неговата нужда от изчислителен ресурс.

- 10.1 Процеси в многозадачната система

	Процесът е работеща програма, съществуваща във времето, има начало и край. Има различни състояния R, A, S.
Процесите могат да бъдат спящи(те чакат входно-изходни операции или момент от времето), активни(в момента активен процес, но който чакат CPU) и работещи(такива, които ползват CPU в момента). 

- 10.2 Превключване, управлявано от синхронизация

 Един процес преминава от едно състояние в друго: 

                     - Преход: Работещ процес да премине в спящо състояние. Този процес се нарича блокиране. Това настъпва, когато процесът чака вх/изх операция(wait-предизвиква се от синхронизиращия механизъм-семафора, семафорът приспива процеса, приспива само ако ресурсът е зает) или ако чака момент от времето(sleep-предизвикан от синхронизираща операция, приспива задължително)
                     - Спящият процес може да премине в активен(събужда се). Събуждането на процеса се предизвиква от завършването на входно-изходна операция на друг процес, който чрез семафор signal() ще подаде сигнал, че е освободен ресурс. 


- 10.3 Превключване в система с времеделене - timer interrupt (часовник/scheduler)

Работещия процес може да стане блокиран (да му се отнеме процесорното време), ако твърде много време е стоял в процесора. В такъв случай времето му изтича, той бива прекъснат от timer, за да освободи CPU ресурс. Това е така, защото в съвременните ОС времето го делим на части и всеки процес има макс количество време, което може да работи. Обслужването на спирането се извършва от алгоритъм в ядрото, а самото спиране от часовника. 

                     - Активният процес, преминава в работещ-това става, когато му се предостави процесорно време. Извършва се смяна на работещия процес, поради изтичане на време на даден процес, ядрото тогава решава, кой чакащ процес да заработи(зависи от алгоритъма на ядрото и то неговия task scheduler).
                     - Когато спящият процес е приспан заради очакване на момент от времето(sleep-приспиването става по желание на процеса), то той може да стане активен, като този процес се инициира от timer(прекъсване на часовника).

### 11. Състояния на процеса и преходи между тях:
 - 11.1 Възможни състояния и места за съхрание на съответните процеси
 - 11.2 R - работещ (заема процесор)
	
	Процес започва жизнения си цикъл в R “бягащо” състояние и завършва след като родителския процес вземе изработеното му от Z “зомби” състояние. 
 
 - 11.3 r - активен ( чака за процесорно време) , run_queue

Активни - които чакат да се освободи процесорно време
В многозадачна ОС много процеси се изпълняват в едно и също време. Активните процеси се съхраняват в структура от данни наречена (масив) run_queue.
Run queue съдържа приоритетните стойности за всеки процес, които ще бъдат използвани от scheduler, за да определи кой ще бъде следващия процес ,който
ще се изпълни. За да се подсигури , че всяка програма има правилно разпределение на ресурсите, всяка една се изпълнява за определено време ,след което
се паузира и се слага в run_queue. Когато програмата е прекъсната, за да се изпълни друга, програмата с най-високия приоритет в опашката се изпълнява
Процесите/програмите се махат от run_queue когато се приспят , когато чакат да се освободи или когато са приключили работата си. 
	
- 11.3 S - спящ ( чака събие, signal() от друг процес или драйвер) ,входно-изходен канал

Процесът изчаква някакво събитие да се случи(като изпълнението на входно/изходна операция) и след това започва своето действие 

- 11.4 Т - чака за настъпването на момент във времето, time_queue

Процесът е зареден в главната памет и изчаква изпълнение върху ЦП. Модерните компютри имат възможността да подкарат множество различни програми или процеси по 1 и също време. Обаче ЦП може да обработва само по 1 процес. Процеси, които са готови за обработка са държани в опашка.

- 11.5 Диаграма на състоянията и преходите между тях


### 12. Синхронен и асинхронен вход/изход
- 12.1 Опишете разликата между синхронни и асинхронни входно-изходни операции

Разликите в синхронните и асинхронните входно-изходни операции са базирани върху начина по който те организират входно-изходните процеси.
При Асинхронните входно-изходни операции или още interrupt driven, целта е да да има възможно най-малко приспани процеси. Този вид операции позволяват на процесите да продължат докато предаването на данни и изпълнението на други процеси приключи и се освободи място. При постъпване на процес се изпараща запитване до ядрото за изпълнение на процеса и ако то се отхвърли и няма възможност за изпълнение на процеса, то той се отпраща, а ако се приеме той се пропуска. 
За разлика от Асинхронните входно-изходни операции, Синхронните организират процесите по по-различен начин. При Синхронните входно-изходни операции, процесорът се обръща към контролера на входно/изходното устройство и подава заявка за извършване на операцията. Тук има повече приспивания и събуждания на процеси. При постъпване на процес, ако не е възможно да се изпълни, той се приспива, докато не се освободи място за неговото изпълнение.

- 14.2 Дайте примери за програми, при които се налага използването на асинхронен вход - изход

Пример за асинхронен вход/изход е pipeline - това е като тръба, по която могат да минава информация само в едната посока.

Втори пример:
SQLite използва асинхронен вход/изход. Попринцип,когато SQLite пише в файл от базата данни,изчаква докато операцията за писане е приключила преди да даде контрол на извикващото приложение. Тъй като писането във файловата система обикновено е много бавно в сравнение с ЦП операции,това може да създаде bottleneck при производителността. Асинхронният вход/изход бекенд е разширение, което кара SQLite да извърши всичките заявки за писане използвайки отделна нишка, която работи на заден план. Независимо че това не намалява използването на системните ресурси(ЦП,скорост на диска), то позволява на SQLite да върне достъп на извиквача бързо дори при писане в базата от данни.


### 13. Teкстова конзола, shell
	//В shell -а може да пишем команди, които се интерпретират от операционната система

- 13.1 Свързане и допускане до UNIX система- login

The login program is used to establish a new session with the system. It is normally invoked automatically by responding to the "login:" prompt on the user's terminal. login may be special to the shell and may not be invoked as a sub-process. When called from a shell, login should be executed as exec login which will cause the user to exit from the current shell (and thus will prevent the new logged in user to return to the session of the caller). Attempting to execute login from any shell but the login shell will produce an error message.
	
- 13.2 Конзола - стандартен вход, стандартен изход, стандартна грешка

	Стандартните потоци са вход и изход комуникационните канали между програма и нейното обкръжение, когато започне да се изпълнява. Трите I/O връзки се наричат стандартен вход(stdin), стандартен изход(stdout) и стандартна грешка(stderr). Когато команда е изпълнена през интерактивен shell, потоците са свързани към текстовия терминал, на който работи shell-a, но може да се промени чрез пренасочване(pipeline). По общо казано, child process ще наследи стандартните потоци на родителя си.

- 13.3 Shell - команден интерпретатор

Когато включим конзолата (след като сме се идентифицирали), стартира програма shell. Тя има много различни реализации (bash, zsh, tcsh, sh). Редът преди курсора се нарича prompt и ни казва в какъв режим работим (обикновен потребител, root)

### 14. Shell - конвейри , пренасочване , филтри 

- 14.1 Файлови дескриптори, номера на стандартните fd, пренасочване -  прави композиция на две програми; p1 | p2 изходните данни от първата се подават като входни на втората

Първоначално, shell-ът казва на ядрото да създаде pipe (тръба). След това шелът(shell) започва да се размножава (fork()). И двата новообразувани процеса изпълняват една и съща програма, но всеки от тях си работи в собствена памет. Новият процес(shell1) наследява всичко от стария. Старият процес наричаме родител. Той остава да работи там, където е бил, докато новият работи с програмата на стария, но си прави копие на цялата памет (прави си нов стек и т.н.).

И така, след fork-а, имаме два shell-a, два процеса, които имат еднакви файлови дескриптори, еднакво съдържание на паметта. Единственото, по което може да се разбере кой е родителят и кой - наследникът, е резултатът, който е върнал fork() - при 0, наследник, при !=0, родител.

### 15. Физически файлови системи

файлът е обект, който съхранява информация, не прилича на процеса. Ние ще приемем само, че файлът е абстракция, която ни предоставя операционната система и която ни дава възможност дълготрайно да съхраняваме информация и също комуникира с останалите обекти.

Файловата система представлява съвкупност от файлове и информация, която описва определени характеристики на всеки от тях. Целта на файловата система е да позволи подредба на файловете с цел по-лесно откриване. Има много файлови системи — те се различават по начина, по който се осъществява подредбата на файловете и по допълнителните характеристики, които се пазят за всеки файл. Тези характеристики могат да включват вид, права за достъп, размер, дата на последна промяна и др. Файловите системи обикновено подреждат файловете в структура, наречена Файлово дърво. Има различни файлове според функциите си във файловата система. Съвременните файлови системи поддържат съотвествие кой е собственика, кой има права на достъп до файла(права и привилегии).

- 15.1. Блочни и символни устройства

Блочни специални файлове или блочни устройства предлагат буфериран достъп до хардуерни устройства и предлагат някаква абстрацкия от тяхната специфика. За разлика от символните устройства,блочните устройства винаги ще позволят на програмиста да чете или пише блок от всякакъв размер и подравняване. Отрицателното на това е,че тъй като блочните устройства са буферирани, програмистът не знае колко време ще отнеме записаните данни да се прехвърлят от кернела в истинското устройство или в какъв ред 2 отделни записа ще пристигнат във физическото устройство.
	
Символно устройство е такова устойство с което диска комуникира чрез изпращане и получаване на информация байт по байт. Пример са звуковите карти, USB
портовете , parallel ports. 
Блочното устройство комуника като изпраща цял блок от данни. Пример са твърдите дискове, USB камерите, 

- 15.2. /etc/fstab, /etc/mtab, mount, df, umount

/etc/fstab - системен конфигурационен файл. Този файл изкарва списък с всички налични дискови партитишиони и други типове на файлове системи,които не трябва задължително да са дисково-базирани, и показва как трябва да се инициализират или интегрират в по-голямата файлова-системна структура.


 /etc/mtab - системен конфигурационен файл. Този файл изкарва списък с всички текущо монтирани файлови системи заедно с техните инициализиращи опции. Mtab прилича на fstab, разликата между двете е,че /dev/fstab изкарва списък с кои налични файлови системи трябва да се монтират по време на буутването,докато първото показва кои са монтирани в момента.


Mount - инструктира операционната система,че файловата система е готова за използване и я асоциацира с отделна точка в общата йерархия на файловата система(mount point) и задава опции свързани с нейния достъп. 


Umount - инструктира операционната система,че файловата система трябва да бъде деасоциацирана от точката и за маунтване, правейки я вече недостъпна и може да бъде изтрита от компютъра. Важно е първо да се umount-не устройство преди да се изтрие.

### 16. Физически файлови системи - реализация

- 16.1 Качества и изисквания към файловите системи
- 16.2 Ефективна реализация, отлагане на записа , алгоритъм на асансьора

Има специални програми (check and repair), които се стартират когато е ясно, че има някакви нарушения в структурата на файловата система, и които проверяват съответствието между метаданните и данните на целия диск. Когато системата има много процеси и едновременно се работи с много файлове, може да се окаже, че тези програми не могат да оправят нещата.

 
Всички съвременни файлови системи са журнални (Journal File System). Концепцията за журналност е въведена първо при базите данни - за транзакциите, които са одобрени и които трябва да се запишат в дисковите пространства, за да бъдат съхранени дълготрайно. За да не се загубят при авария, освен нормалния файл, в който са записани таблиците на базите данни, се съхранява и друг файл, който се нарича журнал (log file). Той е един за цялата база и всяка транзакция се записва първо в журнала. Извърши ли се дадена транзакция изцяло, тя се изтрива от журнала. Тази концепция се използва и при файловите системи - някакъв специален файл (или част от диска) се обявява за журнал и отложените операции се записват в правилния ред в журнала. Докато присъстват там се опитваме да ги запишем в реалните места на диска. Ако успеем, цялата поредица от действия, които са свързани с реалната промяна по даден файл, се изтриват от журнала. В различните журнали се описват различни типове данни.

Алгоритъм на асансьора
Алгоритъмът, който се използва най-често, се нарича алгоритъм на асансьора и предполага, че близки сектори на диска ще се променят бързо. При него имаме указател, който сочи къде се намира главата на твърдия диск в момента, помни се и посоката, в която се движи тя. Заявките се обработват по посока на движение на главата подобно на движението на асансьор - слиза надолу докато изпълни всички заявки, след това обръща посоката и се движи нагоре докато изпълни всичко. Недостатъкът на този алгоритъм е, че може да доведе до голямо забавяне на заявките. Друг алгоритъм е алгоритъмът на най-близкия сектор, който оправя недостатъка на алгоритъма на асансьора, но при него може да се получи starvation.

### 17. Специални файлове
- 17.1. Линкове - твърди и символни, команда ln

Символният линк е прякора на всеки файл, който съдържа референция към друг файл или директория в формата на абсолютен или относителен път.
Твърдият линк е запис на директорията, който асоциацира име с файл във файловата система. Всички директории-базирани файлове системи трябва да имат поне 1 твърд линк давайки оригиналното име за всеки файл. 

ln [OPTION]... TARGET [LINK_NAME] - създава линк към специфицирания TARGET с допълнителната настройка LINK_NAME. Ако LINK_NAME е пропуснат, линкът се създава със същото базово име като TARGET-а в текущата директория.

 Symbolic link contains information about the destination of the target file.
 The important part is that hard link is closely tied together with its originating file. If you make changes to a hard link, you automatically make changes to the underlying file that the hardlink is attached to.
Hard link can only refer to data that exists on the same file system.


- 17.2. сокети

socket - двупосочен комуникационен канал; socket listen и socket connect; тези връзки могат да се създават своевременно и процесите от двете страни не е необходимо да са наследници на общ родител