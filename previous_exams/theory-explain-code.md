# Програми на С

### Зад. 144 2018-CS-01 
Дадена е програма за ОС Linux, написана на езика C:

```c
#include <unistd.h>
#include <string.h>

int main(void) {
    char* buff = "Hello world\n";
    int p;
    if (fork()== 0) write(1,buff,strlen(buff));
    p=fork();
    write(1, buff,(strlen(buff)));
}

```
- Колко пъти ще се отпечата текста Hello world! при изпълнението на програмата? Обосноветеотговора си.

Програмата създава два fork извиквания, което води до създаването на общо 3 нови процеса.
Първия fork създава Дете1, който изпълнява писане вътре в условието if. 
Втория fork се изпълнява от оригиналния процес и Дете1, което създава Дете2 и Дете3.
Всеки от четирите процеса ще изпълни последното писане.

- Нарисувайте кореновото дърво с върхове процесите, които ще се стартират в резултат от изпълнението на програмата и ребра двойките родител-наследник.

```text
        P(Original)
         /      \
    Child1      Child2
      |
    Child3
```


### Зад. 145 2018-SE-02 

Дадена е програма за ОС Linux, написана на езика C:
```c
#include <unistd.h>
#include <stdio.h>

int main(void) {
    int p1, p2;
    p1=fork();
    p2=fork();
    print("Hello world!\n");
}

```
- Колко пъти ще се отпечата текста "Hello world!" при изпълнението на програмата? Обосновете отговора си.

Програмата създава два fork извиквания, което води до създаването на общо 3 нови процеса.
Първия fork създава Дете1.
Втория fork се изпълнява от оригиналния процес и Дете1, което създава Дете2 и Дете3.
Всеки от четирите процеса ще изпълни последното писане.
Следователно ще имаме 4 отпечатвания на  "Hello world!".

- Как работи системното извикване fork()?

fork е системно извикване, което създава нов процес идентичен на процеса, който го е извикал (родителски
процес). fork връща 0 на новосъздадения процес и PID на детето на родителския процес. Това позволява родителя и детето да продължат изпълнението си независимо един от друг.


- Нарисувайте кореновото дърво с върхове процесите, които ще се стартират в резултат от изпълнението на програмата и ребра двойките родител-наследник

```text
        P(Original)
         /      \
    Child1      Child2
      |
    Child3
```

### Зад. 146 2019-CS-02
 Дадена е програма за ОС Linux, написана на езика C:
```c
#include <unistd.h>
#include <stdio.h>

int main(void) {
    int p1, p2, p3;
    p1=fork();
    if (p1 ==0 ) {
        p2=fork();
        if (p2 > 0) p3=fork();
    }
    print("Hello world!\n");
}

```
- Колко пъти ще се отпечата текста "Hello world!" при изпълнението на програмата? Обосновете отговора си.
    
Програмата създава три fork извиквания, което води до създаването на общо 3 нови процеса.
Първия fork създава Дете1, който изпълнява втори fork вътре в условието if, което създава Дете2.
В Дете1, след втория fork се извършва трети if (p2 > 0), което създава Дете3.
Всеки от четирите процеса ще изпълни последното писане.
Следователно ще имаме 4 отпечатвания на  "Hello world!".

- Как работи системното извикване fork()?

fork е системно извикване, което създава нов процес идентичен на процеса, който го е извикал (родителски
процес). fork връща 0 на новосъздадения процес и PID на детето на родителския процес. Това позволява родителя и детето да продължат изпълнението си независимо един от друг.

- Нарисувайте кореновото дърво с върхове процесите, които ще се стартират в резултат от изпълнението на програмата и ребра двойките родител-наследник

```text
        P(Original)
         /      
    Child1      
      |
    Child2
      |
    Child3
```

### Зад. 147 2022-IN-01
Дадена е следната програма на C за GNU/Linux операционна система:

```c
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>

int main(void) {
    pid_t p1, p2, p3;
    write(1, "A", 1);
    p1=fork();
    if (p1 ==0 ) {
        write(2, "BB", 2);
        p2=fork();
        if (p2 > 0) {
            write(1, "C", 1);
            p3 = fork();
            write(2, "DD", 2);
            if (p3 > 0) exit(0);
        }
    }
     write(1, "A", 1);
     exit(0);
}

```
Забележка: Номерата на редовете са за илюстративни цели и не са част от кода на програмата.
При компилиране и стартиране на програмата се създава процес с PID 42. Изберете примерни стойности за PID на всеки създаден процес-наследник.

- Опишете обосновано изпълнението на програмата, като включите следната информация (номерации на редове по условието от сборника):
            
            - процес <42> , ред <8> (write(1, "A", 1);), извежда "A" на stdout
            - процес <42> , ред <9> ( p1=fork();), създава процес <X>
            - процес <42> , ред <22> (write(1, "A", 1);), извежда "A" на stdout
            - процес <42> , ред <23> , терминира (прекратява изпълнението си)

            - процес <X> , ред <12> (write(2, "BB", 2);), извежда "BB" на stderr
            - процес <X> , ред <13> ( p2=fork();), създава процес <Y>
            - процес <X> , ред <16> (write(1, "C", 1);), извежда "C" на stdout
            - процес <X> , ред <17> ( p2=fork();), създава процес <Z>
            - процес <X> , ред <18> (write(2, "DD", 2);), извежда "DD" на stderr
            - процес <X> , ред <19> , терминира (прекратява изпълнението си)

            - процес <Y> , ред <22> (write(1, "A", 1);), извежда "A" на stdout
            - процес <Y> , ред <23> , терминира (прекратява изпълнението си)

            - процес <Z> , ред <22> (write(1, "A", 1);), извежда "A" на stdout
            - процес <Z> , ред <23> , терминира (прекратява изпълнението си)

- Нарисувайте диаграма, която визуализира взаимоотношенията между процесите. Например,
може да нарисувате кореново дърво с върхове процесите, които ще се стартират в резултат от
изпълнението на програмата и ребра двойките родител-наследник. Маркирайте върховете със
съответния PID.
```text
        P(Original) (42)
         /      
    Child1   (X)   
      |
    Child2 (Y)
      |
    Child3 (Z)
```

- Какъв ще бъде изхода на stdout след приключване на процесите? Обосновете отговора си.
Упътване: Не е гарантирано, че системното извикване fork( ) приключва успешно.
 "AACAA" - при успешни създавания на деца.

Редът на А и С може да варира в заивсимост от това кой процес изпълнява кода си по-рано.


Ако ДЕТЕ2 и ДЕТЕ3 не биват създадени би липсави две "А"-та и С.
Ако ДЕТЕ2 е създадено, но ДЕТЕ3 не тогава пак бихме имали "ААСАА" варианти тъй като тогава ДЕТЕ1 няма да терминира по-рано и ще отпечата допълнително А.
Ако ДЕТЕ1 не е създадено, ще се отпечата само "АА".
