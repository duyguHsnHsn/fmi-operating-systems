### 1. Опишете с по едно-две изречения работата на следните системни извиквания в стандарта POSIX:

- **pipe()** – Създава неименувана тръба. Приема масив от две цели числа `int fd[2]`, в който се съхраняват двата нови файлови дескриптора, отнасящи се до краищата на тръбата. `fd[0]` съхранява файловия дескриптор за четене, а `fd[1]` – за писане.

- **dup2()** – Създава копие на файлов дескриптор, подаден като първи аргумент, и го записва на номера на файлов дескриптор, подаден като втори аргумент. Ако вторият файлов дескриптор е отворен, той първо бива затворен преди да бъде използван повторно.

- **fork()** – Създава нов процес, копирайки извикващия процес. Не приема аргументи и връща идентификатор на процеса – новият процес (детето) има стойност `0`, а извикващия процес (бащата) има стойност по-голяма от `0`. При грешка, връща стойност `-1`.

- **exec()** – Системните извиквания от това семейство заменят изпълнимия файл на процеса, който се изпълнява в момента, с друг изпълним файл, подаден като първи аргумент. Следващите подадени аргументи могат да се интерпретират като масив от аргументи, които желаната команда да приеме за своето изпълнение.

- **wait()** – Спира изпълнението на извикващия процес, докато някой от процесите-дете не прекрати своето изпълнение. При подаден аргумент, съхранява подробна информация за детето, променило своето състояние.

- **waitpid()** – Спира изпълнението на извикващия процес, докато процесът-дете с идентификатор, равен на подадения аргумент, не промени състоянието си.

- **open()** – Отваря (или създава) файл с име, подадено като аргумент. Връща като резултат стойността на файловия дескриптор, асоцииран с този файл, а при грешка връща `-1`.

- **close()** – Затваря файлов дескриптор, асоцииран с даден файл.

- **read()** – Приема три аргумента – файлов дескриптор, буфер и брой байтове. Опитва се да прочете съответния брой байтове от файловия дескриптор и да ги запише в буфера.

- **write()** – Приема три аргумента – файлов дескриптор, буфер и брой байтове. Опитва се да прочете съответния брой байтове от буфера и да ги запише във файловия дескриптор.

- **lseek()** – Приема три аргумента – файлов дескриптор, отместване и отправна точка. Премества „курсор“-а във файловия дескриптор, на позиция `<отместване>` според отправната точка. Има три вида отправна точка – `SEEK_SET` – от началото, `SEEK_END` – от края, `SEEK_CUR` – от текущото положение.

- **socket()** – Използва се за създаване на комуникационен канал от тип „конекция“. Създава сокет (крайна точка за комуникация) и връща файловия дескриптор, асоцииран с него.

- **bind()** – Присвоява адрес на сокет, създаден със `socket()`. Това извикване се използва за сървърите в конекцията, изградена със `socket()`, а при клиентите не е необходимо. Тази операция се нарича “именуване на сокет”.

- **connect()** – Свързва сокета, посочен от файловия дескриптор, подаден като аргумент, към адреса на сокета, подаден като аргумент.

- **listen()** – Означава сокета, подаден като аргумент, като готов да приема нови входящи заявки за свързване.

- **accept()** – Блокиращо повикване, което чака входящи връзки. След като заявката за връзка бъде обработена, нов файлов дескриптор се връща. Този нов сокет е свързан с клиента (установена е конекцията), а другият сокет остава в състояние `listen` в очакване на допълнителни връзки.


### 2. Каква е спецификата на файловете в следните директории в Linux:

- **/etc** – Съдържа конфигурационните файлове; файлове, които управляват конфигурацията на конкретната изчислителна система след зареждането на операционната система; информация за потребителите, пароли и т.н.

- **/dev** – Съдържа драйверите на системата; в нея се описват устройствата, които са част от изчислителната система; съдържа псевдо файлове, които задават какъв хардуер може да бъде обслужван от нашата система и какъв точно се обслужва.

- **/var** – Системни файлове – logging files, mail directories, printer spool и др.; за данни, не на потребителя, а за споделени данни.

- **/boot** – Информация за ОС преди самото й стартиране; неща, свързани със зареждането на операционната система.

- **/usr/bin** – Съдържа повечето изпълними файлове, които не са необходими за стартиране или поправяне на системата.

- **/home** – Home директориите на потребителите в системата; файловете на конкретните потребители.

- **/usr/lib** – Обектни файлове и библиотеки; може да включва и вътрешни двоични файлове, които не са предназначени да бъдат изпълнявани директно от потребители или shell скриптове.

- **/var/log** – Директорията, съдържаща всички log (журнални) файлове.

- **/proc** – Информация за операционната система в реално време; съдържа псевдо файлове със статистическа информация от ядрото.

- **/bin** – Съдържа изпълними файлове; важни програми, които се изпълняват при стартирането на системата, общодостъпни програми.

- **/usr/doc** – Съдържа всичката необходима документация.

### 3. Опишете функционалността на следните команди в Linux:

- **cd** – Променя текущата директория.
- **mkdir** – Създава директория.
- **rmdir** – Премахва директория.
- **cp** – Копира файл/файлове в посочена дестинация.
- **mv** – Премества/преименува файлове в зададена дестинация.
- **rm** – Премахва файлове.
- **ls** – Показва съдържанието на директория.
- **who** – Показва активните потребители в момента на извикване.
- **find** – Търси файлове/директории по зададени параметри.
- **ps** – Показва подробна извадка за процесите в ОС в момента на извикване.
- **top** – Подобна на командата `ps`, показва подробна информация за процесите в ОС в реално време.
- **vi** – Отваря на конзолата текстов редактор.
- **tar** – Създава компресирани или некомпресирани архивни файлове или ги поддържа и модифицира.
- **gcc** – Компилира програми, написани на C и C++ код.
- **echo** – Показва на дисплея ред от текст/низ, подаден като аргумент/на стандартния вход.
- **read** – Прочита ред текст, подаден на стандартния вход.
- **test** – Проверява типове на файлове и сравнява стойности (числови или низове).
- **if** – (`if <условие>; then <списък команди> fi`); изпълнява команди въз основа на подадени условия; ако подаденото `<условие>` е изпълнено, се изпълнява `<списък команди>`; тялото на конструкцията приключва с думата `fi`; в случай че първоначалното условие не е изпълнено, позволява проверка на допълнителни условия с ключовата дума `elif` – от `else if`; ако никое от подадените условия не е вярно, в `else` могат да се запишат команди, които да бъдат изпълнени.
- **for** – (`for <елемент> in <множество>; do <команди> done`); изпълнява итеративно (циклично) набор от `<команди>` за всеки `<елемент>`, присъстващ в подадено `<множество>`.
- **while** – (`while <условие>; do <команди> done`); изпълнява итеративно (циклично) набор от `<команди>` докато дадено `<условие>` е изпълнено.
- **chmod** – Променя правата на подадените файлове според подадените стойности (могат да бъдат представени както числово, така и символно).
- **cat** – Прочита съдържанието на файл и го извежда на стандартния изход.
- **grep** – Търси редове, отговарящи на подаден образец (pattern), и извежда само съвпадащитsе редове на стандартния изход.
- **cut** – Извежда само избрани секции/части от редовете на подаден файл/текст; разделя редовете на отделни колони спрямо подаден символ за разделител (по подразбиране е спейс/табулация).
- **sort** – Сортира редовете на подаден файл/текст и извежда сортираното съдържание на стандартния изход.
- **wc** – Извежда броя на новите редове, думите и байтовете за подаден файл.
- **tr** – Заменя символи в даден файл според подадено множество със съответните символи на същата позиция във второто множество или изтрива всички срещания на символите от първото множество.



### Тема 1

Опишете как ОС разделят ресурсите на изчислителната система, дайте примери за основните типове разделяне: 
- Разделяне на пространцството 
- Разделяне на времети (процесори, други устройства).


Опишете с по едно-две изречения разботата на следните системни извиквания в стандарта POSIX:
pipe() dup2() fork() exec() wait() waitpid()

<hr>

- Разпределението на времето се отнася до управлението на процесорното време и достъп до ресурси, като например  входно-изходни устройства, така че да бъдат споделени между няколко процеса или задачи. При разпределянето на процесорното време голяма роля играе типа на процеса. Има няколко вида процеси:
    - foreground/IO процеси – това са процеси, които извършват много входно-изходни операции (например чакат потребителя да въведе някакви данни, да натисне бутон и т.н.). Тези процеси не се нуждаят от много процесорно време, но за тях е характерно, че често ще бъдат приспивани, т.е. ще прекарват много време в структурите между Running и Active, и за тях е важно когато бъдат събудени, много бързо да преминават към Running състояние, т.е. много бързо да им се дава процесорно време, когато го поискат.
    - background/CPU процеси – това са процеси, които извършват много изчисления, т.е. те няма често да бъдат приспивани. Характерно за тях е, че имат нужда от много процесорно време, но няма значение кога ще им бъде предоставено, т.е. няма значение кога ще им се даде възможност да преминат към Running състояние, но е важно, когато са Running състояние, те да прекарат достатъчно време там.
    - real-time процеси - за тях е характерно, че имат определен срок (deadline), в който трябва да им се предостави процесорно време; такива процеси често се срещат например в медицинските роботи, където трябва да се извърши дадена операция и реда и времето на изпълнение на процесите са от критична важност.
    - Важно е предоставянето на процесорно време да бъде съобразено с типа на процесите. В днешните системи за определянето на реда, по който се предоставя процесорно време на процесите се извършва от т.нар. диспечер или Task scheduler. Най-простият начин е процесите, които искат процесорно време, да се пазят в обикновена опашка, като първия процесор, който е пожелал процесорно време, е и първия на който се предоставя. Сигурно е, че няма да настъпи гладуване, т.е. всеки процес след определено време ще бъде предоставен процесор. Проблемът е, че не се взима предвид типът на процесите. Ако даден foreground процес поиска процесорно време, той трябва да изчака всички процеси преди него да завършат, за да получи възможност за работа. В днешните системи се използват много по-сложни начини за определяне на реда. Например на всеки от процесите може да бъде присвоен приоритет 1000, като при всяко изпълнение на процеса, от този приоритет се изважда времето, за което е работил процеса, като се взима процесът с най-висок приоритет. Така, ако даден CPU процес е чакал прекалено дълго, със сигурност ще му бъде дадено процесорно време в определен момент. Друг вариант са fixed и floating приоритети. Всеки път, когато на процесор не му бъде дадено процесорно време се увеличава fixed приоритетът и накрая се взима процесът с най-висок приоритет.
- Разделяне на пространството се отнася до управление на паметта в изчислителната система, ъака че различните процеси да имат достъп до паметта, без да се нарушава тяхната изолация или безопасност. Ресурса е разделен на части и всеки процес получава част от него. Изолацията гарантира, че един процес не може да чете или пише в паметта на друг процес. При разделяне на пространството от значение са не само активните процеси, но и приспаните, тъй като те все пак се нуждаят от даден блок от памет, където да съхраняват данните които използват. Ресурсът се разделя на части и всяка програма или потребител получава част от него. Проблемите, които ОС трябва да решава са следните: Да следи свободните и заети части, да осигури защита на частите, справедливо да разделя ресурса. Примери за ресурси, управлявани по този начин, са оперативна памет и дискова памет. Има два вида разделяне на паметта - статично и динамично; при статичното трябва да се знае каква е максималната големина на всеки файл, като се заделят n последователни блока, в които може да се запише файлът. Това осигурява много бърз достъп до данните, но на практика при повечето файлове не знаем каква ще бъде големината им и искаме да можем да се увеличават, динамично; при втория тип, файлът се разделя на т.нар. фрагменти с определена дължина, като тези фрагменти се разхвърлят по паметта; по този начин не се пази максимална големина на файла, и нарастването му няма да доведе до проблеми.

### Тема 2

- Опишете разликата между времеделене и многозадачност.
- Какви ресурси разделя еднозадачна, еднопотребителска ОС? 

- Опишете с по едно-две изречения разботата на следните системни извиквания в стандарта POSIX:
open() close() read() write() lseek()

<hr>

#### Опишете разликата между времеделене и многозадачност
- Първи отговор: 
    - Времеделенето е споделяне на изчислителен ресурс между много потребители чрез едновременна многозадачност, докато многозадачността е едновременно изпълнение на множество задачи или процеси за определен период от време. Докато споделянето на времето позволява на множество потребители да използват компютърна система едновременно, многозадачността позволява на множество задачи или процеси да използват компютърна система наведнъж. Следователно, многозадачността стои в основата времеделенето.
- Втори отговор: 
    - Времеделенето е техника, при която множество потребители или процеси споделят процесорното време на една изчислителна система. Всеки процес или потребител получава малък времеви отрязък от процесорното време, след което системата превключва към следващия. Това създава илюзия, че всички процеси се изпълняват едновременно, въпреки че в действителност процесорът обслужва един процес във всеки даден момент. Времеделенето е основна концепция в съвременните ОС, особено при многопотребителските системи.
    - Многозадачността е способността на ОС да управлява и изпълнява множество задачи и процеси за определен период от време. Това позволява на множество задачи или процеси да използват компютърната система наведнъж. Това може да се постигне чрез времеделене (превключва менду задачи), но също така може да включва и паралелно изпълнение, ако системата разполага с множество процесорни ядра. 
    - Многозадачността е по-общо понятие, което се отнася до изпълнението на множество задачи едновременно, докато времеделенето е техника за споделяне на изчислителен ресурс между много задачи. 


 #### Какви ресурси разделя еднозадачна, еднопотребителска ОС? 

Еднозадачната еднопотребителска ОС е операционна система, която позволява на един потребител да изпълнява само една задача наведнъж. Функции като отпечатване на документ, изтегляне на изображения и т.н., могат да се изпълняват само по една. Тази операционна система заема по-малко място в паметта. Еднозначната еднопотребителската заделя всички ресурси за този един потребител и тази една задача.

### Тема 3

- Дайте кратко определение за многозадачна ОС, многопотребителска ОС, времеделене.
- Опишете разликата между многопотребителска и многозадачна работа. Какви качества на ОС характеризират тези две понятия? 
- Опишете с по едно-две изречения разботата на следните системни извиквания в стандарта POSIX: open() close() lseek() pipe() dup2()

<hr>

#### Дайте кратко определение за многозадачна ОС, многопотребителска ОС, времеделене

- Многозадачната ОС изпълнява няколко задачи едновременно. Това се постига чрез разделение на времето на работа на процесора според инструкциите на специална подсистема (task scheduler). При разпределена многозадачност, ОС отпуска на задачата определено време да ползва процесора. Ако тя не успее да приключи за това време, ОС я форсира да отстъпи процесора на следващата задача, която се нуждае от него. При кооперативната многозадачност, приложението, стартирано от ОС, използва 100% от процесора. В този случай, ако друга програма изиска процесорно време, то или няма да ѝ бъде предоставено, което ще доведе до нарушаване на функциите на това приложение и/или до терминирането му, или ще бъде предоставено след приключване на първото.
- Многопотребителската ОС разширява концепцията за многозадачност, като различават потребителите по отношение ползването на процеси и ресурси, като например дисково пространство. Те планират ефикасното използване на ресурсите на системата и могат да съдържат специализиран софтуер за изчисление на процесорното време от много потребители, както и да отчитат използваната памет, ползване на принтер и други използвани ресурси.
- Времеделенето е техника, при която множество потребители или процеси споделят процесорното време на една изчислителна система. Всеки процес или потребител получава малък времеви отрязък от процесорното време, след което системата превключва към следващия. Това създава илюзия, че всички процеси се изпълняват едновременно, въпреки че в действителност процесорът обслужва един процес във всеки даден момент. Времеделенето е основна концепция в съвременните ОС, особено при многопотребителските системи.Времеделенето позволява създаването на многопотребителски системи, в които централният процесор и блокът на оперативната памет обслужват много потребители. При това част от задачите (като въвеждане или редактиране на данни) могат да се изпълняват в диалогов режим чрез терминали, а други (като обемните изчисления) – в пакетен режим.

#### Опишете разликата между многопотребителска и многозадачна работа.

Разликата между многопотребителска и многозадачна операционна система е, че при многозадачната ОС е възможно да имаме един потребител, който да иска едновременно да изпълнява няколко задачи. При многопотребителската система имаме множество от потребители, всеки от които иска да изпълнява някакви задачи, като се предоставя възможност на всеки от потребителите да работи, като по този начин изглежда, че за всеки потребител има отделно ядро, което всъщност не е така.

### Тема 4

- Опишете ситуацията съревноваване за ресурси (race condition), дайте пример. 
- Опишете накратко инструментите за избягване на race condition: 
    - дефинирайте критична секция, атомарна обработка на ресурса 
    - инструменти от ниско ниво, специфични хардуерни средства
    - инструменти от високо ниво, които блокират и събуждат процеси
- Каква е спецификата на файловете в следните директории в Linux: /etc /dev /var /boot /usr/bin /home /usr/lib /var/log

<hr>

#### Опишете ситуацията съревноваване за ресурси (race condition), дайте пример.

Race condition, буквално може да се преведе "борба за ресурси" е състояние, което настъпва когато два или повече процеса едновременно се опитат да достъпят даден споделен ресурс, като започва надпревара за това кой процес ще достъпи паметта първи, което води до непредвидими или нежелани резултати. Това може да настъпи както в мултипроцесорна, така и в еднопроцесорна система, в който случай изпълнението на програмата може да зависи от интервалите между инструкциите, които се изпълняват последователно от един процесор. Например, ако два процесса зависят от стойността на една глобална променлива и двата процеса променят и цетат стойността на променливата, но реда на изпълнение не е определен, може да се стигне до ситуация, където единия процес променя стойността на променливата, докато другия процес очаква тя да бъде старата. 


#### Опишете накратко инструментите за избягване на race condition
- дефинирайте критична секция, атомарна обработка на ресурса.
    - Критична секция: Всеки процес, който работи със споделен ресурс има поне едно място в кода си, в което той използва този споделен ресурс. Тази част от кода се нарича критична секция.
    - Атомарна обработка на ресурса: Инструкции, които променят бит и го прочитат след това като една единна непрекъсната инструкция.
- инструменти от ниско ниво, специфични хардуерни средства.
  - Най-простият инструмент за избягване на race condition e spinlock. Това е инструмент на най-ниско ниво, който на практика ни дава възможност да "заключим" достъпа до даден ресурс, когато го използваме ние, и да го "отключим" в последствие, когато вече не го използваме. Това става с наличието на един допълнителен бит, който ни указва дали ресурса е свободен за използване, или не е. Това обаче не е достатъчно, тъй като ако даден процес се извика рекурсивно, то всеки следващ процес ще зацикли и бита никога няма да се освободи, т.е. паметта ще остане винаги заключена, т.нар. deadlock. Освен този бит, е важно да се забранят прекъсванията, така че да не може да се стигне до зацикляне. В spinlock присъстват следните хардуерни инструменти за защита – enable/disable interrupt, test-and-set и atomic swap.
- инструменти от високо ниво, които блокират и събуждат процес.
	- Семафорът е абстрактен механизъм от високо ниво за синхронизация на процеси, използващи общи ресурси. Основава се на принципа за приспиване и събуждане на процес. Ако един процес няма работа, която да извърши в даден момент, и очаква външно събитие, то той бива приспан до настъпване на чаканото събитие. Когато споделеният ресурс е наличен отново, процесът се събужда и продължава изпълнението си от там, докъдето е стигнал


### Тема 5 

- Хардуерни инструменти за защита(lock) на ресурс:
    - enable/disable interrupt
    - test and set 
    - atomic swap
- Опишете инструмента spinlock, неговите предимства и недостатъци.
- Каква е спецификата на файловете в следните директории в Linux: /etc /dev /var /proc /bin /home /usr/doc

<hr>

#### Хардуерни инструменти за защита(lock) на ресурс

- enable/disable interrupt: Инструкцията блокира временно хардуерните прекъсванията, след което може пак да ги разрешава. Когато се влезе в режим на работата в ядрото, кода извиква процедура от ядрото да го изпълни и може да се сложи в опашката инструкция да спре и да пусне прекъсванията.
- test and set: Тази инструкция се използва, за да се пише в паметта и да се върне старата стойност като атомарна операция.
- atomic swap: Атомарната инструкция се използва да се постигне синхронизация. Тя сравнява съдържанието на локация в паметта с дадена стойност и само ако са същите, модифицира съдържанието с новата стойност.

#### Опишете инструмента spinlock, неговите предимства и недостатъци

Това е инструмент на най-ниско ниво, който на практика ни дава възможност да "заключим" достъпа до даден ресурс, когато го използваме ние, и да го "отключим" в последствие, когато вече не го използваме. Основната задача на spinlock е да предотврати конкурентния достъп до споделен ресурс от няколко процеса едновременно, като използва активно изчакване (spin-waiting) вместо да блокира процеса, който се опитва да влезе в критичната секция.
Приемаме че хардуерът разполага със специални инструменти за атомарна обработка на ресурсите, напр. test_and_set(), който атомарно (като 1 инструкция) да проверява каква е текущата стойност и съответно да присвоява нова стойност. Базирайки се на това допускане, можем да дефинираме друг инструмент от ниско ниво за справяне със race condition - т.нар spinlock. При него имаме един допълнителен бит - lock, който пази стойност 0 ако ресурса е свободен, и стойност 1, ако е зает. Тъй като този бит е споделен ресурс за обработката му ще използваме test-and-set. Реализацията на този инструмент би изглеждала така:
```
spinlock R=test_and_set(lock)
if(R==1) goto spinlock
critical_section
unlock(lock)
```
Тук обаче е възможно да възникне проблем, ако процесора прекъсне изпълнението на процеса, затова е важно да се забранят прекъсванията.

```
spinlock disable_interrupts
R=test_and_set(lock)
if(R==0) goto critical_section
enable_interrupts
goto spinlock
critical_section
unlock(lock)
enable interrupts
``` 

Важно е да се отбележи, че не можем да имаме рекурсия в критичната секция, защото по този начин извикания процес ще чака lock-a да се освободи, а текущия процес ще чака рекурсивно извикания да приключи своето изпълнение - което никога няма да се случи, т.е. ще настъпи deadlock.

- Недостатъци: ако критичната секция, за която се изполва spinlock, има дълга продължителност на изпълнение, активното изчакване на процесора може да доведе до загуба на производителност
- Предимства: при кратки критични секции или при наличие на много ядра, които освобождават ресурси бързо, времето прекарано в контекстно превключване, може да бъде по-фълго от активното изчакване


### Тема 6 

- Опишете понятията приспиване и събуждане на процес(block/wakeup)
- Семафор - дефиниция и реализация
- Опишете разликата между слаб и силен семафор
- Опишете накратко различните видове специални файлове в Linux: външни устройства наименувани в /dev, псевдофайлове в /proc, линкове - твърди и символни, команда ln, сокети

<hr>

#### Опишете понятията приспиване и събуждане на процес(block/wakeup)

Когато даден процес чака определено събитие да настъпи, независимо дали това събитие е някакъв момент във времето, някакви входно-изходно операции, или конкретно събитие, той бива приспан (block). Обикновено процесът се приспива сам, като извика block(), а по-късно, когато настъпи конкретното събитие, някакъв друг процес го събужда (wakeup).  Приспиваните процеси не използват процесорно време. Пример: процес може да бъде приспан, ако изчаква данни да бъдат прочетени от входно устройство или ако е в опашка за достъп до заключен ресурс.

#### Семафор - дефиниция и реализация

- Семафорът е абстрактен механизъм от високо ниво за синхронизация на процеси, използващи общи ресурси. Основава се на принципа за приспиване и събуждане на процес. Ако един процес няма работа, която да извърши в даден момент, и очаква външно събитие, то той бива приспан до настъпване на чаканото събитие. Когато споделеният ресурс е наличен отново, процесът се събужда и продължава изпълнението си от там, докъдето е стигнал. Семафорът преставлява абстрактен тип от данни, който се използва за броене или за ограничаване на броя на процесите, които могат да достъпят даден ресурс едновременно. 
- Имплементация на семафор 
```c
// pseudo code
struct Semaphore{
    int cnt =0
    list L = () 
    bit lock = 0

    init(int _cnt) {
        cnt = _cnt
    }

    wait(){
        spin_lock(lock);
        cnt = cnt - 1
        if (cnt < 0) {
            L.put(self);
            spin_unlock(lock)
            block()
        } else spin_unlock(lock)
    }

    signal(){
        spin_lock(lock);
        cnt = cnt + 1
        if (cnt <= 0) {
            pid = L.get()
            spin_unlock(lock)
            wakeup(pid)
        } else spin_unlock(lock)
    }
}
```
- Структурите от данни, необходими за реализация на семафор са: Брояч cnt, в който се пази броя на процесите, които могат да бъдат допуснати до ресурса, охраняван от семафора. Контейнер Q, в който се пази информация кои процеси чакат достъп до ресурса.
- Процедурите (методите), необходими за реализация на семафор са: Конструктор init(int n), който задава начална стойност на брояча n и инициализира контейнера празен. Метод wait(), който се ползва при опит за достъп до ресурса. Броячът се намалява с единица и ако той стане отрицателен, процесът, извикал wait() се блокира, а номерът му се вкарва в контейнера Q. Метод signal(), който се използва при освобождаване на ресурса. Броячът се увеличава с единица и ако контейнерът Q не е празен, един от процесите в него се изкарва и активира.

#### Опишете разликата между слаб и силен семафор

Един семафор е силен, когато контейнерът Q е реализиран като обикновена опашка (на принципа „first in, first out“ – активираме процеса, блокиран най-рано). Семафорът е слаб, когато контейнерът Q е реализиран като приоритетна опашка – активираме процес, който не е влязъл най-рано в него.

####  Опишете накратко различните видове специални файлове в Linux: външни устройства наименувани в /dev, псевдофайлове в /proc, линкове - твърди и символни, команда ln, сокети

- външни устройства, именувани в /dev – файловете в тази директория са псевдофайлове, съответстващи на периферни устройства; задават какъв хардуер може да бъде обслужван от нашата система и какъв точно се обслужва;
- псевдофайлове в /proc – В директорията /proc е вградена виртуалната файлова система Proc file system (procfs), която се създава в движение при стартиране на системата и се разтваря в момент на спиране на системата. Тук се съдържа полезна информация за процесите, които се изпълняват в момента – разглежда се като контролен и информационен център за ядрото. В директорията има директории с име PID на всеки процес в системата, всяка от които съдържа подробна информация за този процес.
- линкове – твърди и символни, команда ln
    - Symbolic link – псевдофайл, който представлява алтернативно име за друг файл или директория. Те могат да сочат към всички видове файлове (нормални файлове, директории, специални файлове, други символни линкове и т.н.). Ако бъде преименуван, преместен или изтрит оригиналният файл, линкът става невалиден (счупен; broken). Те могат да имат различни права на достъп от файловете, към които сочат.
    - Hardlink – За разлика от symbolic links, които сочат към името на друг файл, твърдите линкове се насочват към inode-а на съществуващ файл. По този начин различни имена на файлове се свързват към един и същ inode. Не могат да сочат към директории. Преименуването, преместването или изтриването на „оригиналния“ файл няма ефект върху тях. Промяната на правата на достъп на файл променя правата на достъп на всички негови твърди линкове.
    - ln – създава линкове към файлове; ако не подадем на командата никакви флагове, тя създава hardlink на подадения файл; ако подадем на командата -s, тя създава symbolic link на подадения файл 
- сокет - специален файл, използван за комуникация между процесите (инструмент за създаване на комуникационен канал от тип конекция), който позволява комуникация между два процеса без роднинска връзка. За разлика от именуваните тръби, които позволяват само еднопосочен поток от данни, сокетите са напълно съвместими с дуплекс. При изпълнение на команда ls -l, сокетите са отбелязани със символ ‚s‘ като първа буква на символната репрезентация на правата за достъп.

### Тема 7

- Взаимно изключване - допускане само на един процес до общ ресурс. Опишете решение със семафори. 
- Качества и свойства на конкретните файлови системи, реализирани върху block devices. 
- Ефективна реализация, отлагане на записа, алгоритъм на асансъора.

<hr>

#### Взаимно изключване - допускане само на един процес до общ ресурс. Опишете решение със семафори. 

- Взаимно изключване (mutual exclusion или mutex) е основен принцип в синхронизацията на процеси, който гарантира, че само един процес може да има достъп до даден общ ресурс в даден момент. Това предотвратява възникването на race condition, при който два или повече процеси едновременно манипулират споделен ресурс, което може да доведе до непредсказуемо поведение или повреда на данните. При взаимното изключване искаме най-много един процес да достъпва определен споделен ресурс по едно и също време. Например, нека p1, p2 и p3 формират критичната секция на процеса P и нека P има много копия, т.е. множество копия на P могат да работят паралелно. Искаме само едно копие на P да може да достъпва критичната секция по едно и също време.
- Тази синхронизационна задача може да се реши като си дефинираме семафор s така и добавим следните синхронизационни инструкции в кода на P:
```
s.init(1);

P
s.wait()
p1
p2
p3
s.signal()
```
- По този начин, първото копие на процеса P ще започне да изпълнява критичната си секция, като брояча на семафора ще стане 0. След това, всяко следващо копие, което се опита да достъпи критичната секция ще бъде приспивано, докато първото не приключи изпълнението си, и не събуди едно от приспаните копия.

#### Качества и свойства на конкретните файлови системи, реализирани върху block devices. 

Съвременната файлове система, реализирана върху блоково устройство, трябва да удовлетворява няколко основни изисквания и да използва различни инструменти за подобряване на ефективността и надежността на операциите с данни. 
Изисквания, които удовлетворява съвременната файлова система върху блоково устройство: 
- организация на данни - ФС трябва да организира данните върху блокове на физическото устройство. Блокът е минималната единица за четене и запис
- управление на пространството - ФС трябва да управлява свободното и заетото пространство на устройството, включително алокация и освобождаване на блокове
- кеш - използване на кещ памет за подобряване на скоростта на достъп до често използвани блокове
- осигуряване на цялост - ФС трябва да осигури цялост на данните, осигурявайки тяхното коректно съхранение и възстановяване в случай на сбой (журнална файлова система)

#### Ефективна реализация на файловата система 
- Твърд диск – това е диск разделен на много „пътечки“:
    - Над повърхнината има устройство, което засича дали битът е 1 или 0;
    - Придвижването на главата на това устройство от една пътечка на друга е механично и става бавно;
    - Всяка пътечка е разделена на няколко сектора от по 512 или 1024 байта;
    - Главата не се допира до диска, а лети много малко над повърхността;
    - Софтуера знае колко е голям сектора и колко е времето за преминаване от един до друг сектор;
    - Файла се представя като много сектори;
    - Не са последователно разпределени байтовете на файловете, защото така не могат лесно да нарастват;
    - Файлът се разполага там където може, процесът на разхвърляне се нарича фрагментация.

#### Отлагане на запис

Цел: отлагането на запис се използва за подобряване на ефективността на ФС чрез събиране на няколко операции за запис в един или повече блокове преди тяхното физическо записване на устройството. 
- Записваме промените във файл, който се нарича журнал – в него се запазва пълната информация за операциите над файлове и когато се запълни журналът, спираме и отразяваме операциите от журнала над файловете. Ако спре токът, журналът ще пази последните промени, а файловете ще са консистентни. Четат се първо старите файлове и се проверява дали в журнала са променени. Ако спре токът, докато пишем операцията/транзакцията, тя няма да се е изтрила преди да е завършила и затова ще я пазим все още в журнала. Във файловите системи транзакцията е елементарна файлова операция (read, write, open). Журналът (log файл) се намира или в друг диск или в друг дисков дял, за да може двете паралелно да работят, но в персоналните устройства журналът е файл в самата файлова система или в същия дял.

#### Алгоритъм на асансъора 

Цел: Този алгоритъм се използва за оптимизиране на времето за достъп до блокове на твърдия диск, като се минимизира времето за търсене на главата на диска. 
- Реализация: главата на диска се движи по направление нагоре или надолу върху пътеката на диска. Когато се инициира операция за четене или запис  на блок от данни, алгоритъмът определя последователността, в която ще бъдат достъпвани блоковете върху диска. Той работи по следния начин: 
    - Алгоритъмът започва от текущото положение на главата на диска
    - Ако има още блокове за достъпване в същото направление (нагоре или надолу), главата продължава движението си
    - Когато няма повече блокове в текущото направление, главата ще се обърне и ще продължи в противоположното направление
    - това продължава до достигане на последния блок, който трябва да бъде достъпен
- Алгоритъмът на асансьора се изразява в следното: Разместват се така заявките към четене и писане, че главата да изминава минимално разстояние; Има две приоритетни опашки: едната се състои от файлове, които се намират по посока на движението на главата, а другата от файлове, които се намират в обратната посока; Ако е празна главата на опашката по посока на главата на устройството, то се сменя посоката.


### Тема 8 

- Комуникационна тръба (pipe), която съхранява един пакет информация- реализация чрез редуване на изпращача/получателя
- pipe с буфер - тръба, съхраняваща n пакета информация. Използване на семафори като броячи на свободни ресурси
- Права и роли в  UNIX, командата chmod
- Роли - u/g/o user/group/other
- Права - r/w/x read/write/execute

<hr>

#### Комуникационна тръба (pipe), която съхранява един пакет информация- реализация чрез редуване на изпращача/получателя

Комуникационната тръба е механизъм за междупроцесна комуникация, която позволява на един процес да изпраща данни към друг. В случая, ще реализираме тръба, която може да съхранява един пакет информация като се редуват изпращача и получателя. Тази реализация изисква синхронизация, за да се гарантира, че изпращачът няма да изпрати нов пакет преди получателят да е прочел текущия, и обратното - получателя да не се опитва да чете преди да има нещо изпратено. 
- реализация със семафора и каунтър

#### pipe с буфер - тръба, съхраняваща n пакета информация. Използване на семафори като броячи на свободни ресурси

- Тръбата се ползва от няколко паралелно работещи изпращачи/получатели на байтове. Процесите изпращачи слагат байтове в края на опашката, получателите четат байтове от началото на опашката.
- Необходими структури от данни:
    - Опашка (или масив) Q с n елемента – тъй като е възможно да имаме бърз и бавен процес (например: единия чете бързо, а другия пише бавно) е нужно опашката да бъде по-дълга, за да не се приспива по-бързия процес (приспиването е бавна операция, тъй като включва в себе си смяна на контекста). В началото тази опашка ще е празна;
    - free_bytes - семафор, който ще индикира за свободните байтове в опашката;
    - ready_bytes - семафор, който ще индикира колко байта са готови за четене (до колко е запълнена опашката);
    - mutex_read – мутекс, който ще защитава критичната секция за четене;
    - mutex_write - мутекс, който ще защитава критичната секция за писане.
- Процесът, който чете, първоначално ще проверява дали има готови за четене байтове. Ако няма, той ще се приспи и ще чака да постъпят такива. Ако има, той ще провери дали някое друго копие на P не чете в момента. Ако да, той отново се приспива. Ако не, той ще прочете байт и ще го запише в променливата. След това ще сигнализира, че в опашката има още един свободен байт чрез подаване на сигнал на семафора free_bytes.
- Процесът, който пише, първоначално ще провери дали има свободни байтове в опашката. Ако няма, ще се приспи и ще чака да се освободят байтове. Ако има, ще трябва да провери дали някое друго копие на пишещ процес не пише в момента в опашката. Ако да, то отново процеса ще се приспи. Ако не, ще сложи байта си  в опашката и ще сигнализира, че още един байт е готов за четене, което се осъществява чрез подаване на сигнал на семафора ready_bytes.
```
Инициализация:
free_bytes.init(n)
ready_bytes.init(0)
mutex_read.init(1)
mutex_write.init(1)

READ:	           
byte b
p1
p2
…
ready_bytes.wait()
mutex_read.wait()
 b = Q.get()
mutex_read.signal()
free_bytes.signal()


WRITE:
byte b
q1
q2
…
free_bytes.wait()
mutex_write.wait()
 Q.put(b)
mutex_write.signal()
ready_bytes.signal()
```

#### Права и роли в UNIX

- Роли – u/g/o user/group/others
    - Всеки файл и директория имат 3 вида групи по отношение на роли: Потребител (User/Owner), Група (Group) и Други (others).
        - Потребителят е собственикът на файла. По подразбиране, при създаване на файл, лицето, създало файла, става негов собственик.
        - Групата съдържа множество потребители. Всички потребители, принадлежащи към групата, на която принадлежи файлът, имат едни и същи права за достъп.
        - Други са всички останали потребители - нито са собственици на файла, нито принадлежат към потребителската група, притежаваща файла. На практика това означава всички останали.
- Права – r/w/x read/write/execute
    - Всеки файл и директория има 3 вида права: Четене (Read), Писане (Write) и Изпълнение (Execute).
        - Четене: Дава правото да отваряме и да четем съдържание на даден файл. При директориите, дава възможност да видим нейното съдържание.
        - Запис: Дава правомощието да променяме съдържанието на файл. При директориите, дава правото да добавяме, премахваме и преименуваме файлове, съхранявани в директорията.
        - Изпълнение: Ако разрешението за изпълнение не е зададено, не можем да стартираме изпълним файл. При директориите ситуацията е малко по-особена. Ако сравним с правата за четене, там можем само да видим съдържанието на дадената директория (например с команда ls), но ако нямаме права за изпълнение за дадената директория, не можем да я достъпваме.
- chmod – правата за различните роли и групи се сменят с командата chmod. Тя приема като аргументи символна или числена репрезентация на новите права, които искаме да зададем за конкретния файл, както и самия файл, който искаме да променим.


### Тема 9 
 - Взаимно блокиране (deadlock)
 - Гладуване (livelock, resource starvation)
 - Пример: задача за философите и макароните
 - Единна йерархична файлова система в UNIX
 - Файлове и директории, команди - cd, mkdir, rmdir, cp, mv, rm

 <tr>

#### Взаимно блокиране

Deadlock е събитие, което се настъпва, когато процес чака друго събитие, което никога няма да се случи. Обикновено това се получава, когато нишка/процес чака мютекс или друг семафор, който никога не се освобождава от предишния си ползвател, както и при ситуации, когато имаме два процеса и две заключвания.
```
Thread 1:                   Thread 2:
Lock1 -> lock()         Lock2 -> lock()
WaitForLock2()	        WaitForLock1()
```
- Има четири условия, които трябва да бъдат изпълнени, за да можем да сме сигурни, че ще възникне deadlock:
    - Условие за взаимно изключване. Поне един процес да използва споделен ресурс монополно, т.е. да има ексклузивни права над него (да няма възможност друг процес да наруши работата му).
    - Условие за задържане и изчакване. Може да се случат поредици при които процес взима даден ресурс и чака да вземе следващия.
    - Ползването на споделен ресурс в първото условие да не може да бъде прекъсвано от външен фактор.
    - Условие за кръгово (циклично) изчакване.

#### Гладуване (livelock, resource starvation)

- Livelock се случва, когато два или повече процеса непрекъснато повтарят едно и също взаимодействие в отговор на промените в другите процеси, без да извършват полезна работа. Тези процеси не са в състояние на изчакване и те се изпълняват едновременно. Това е различно от deadlock, тъй като при deadlock всички процеси са в състояние на изчакване. Правят се непрекъснати опити за изпълнение на определена задача, но не успяват да я завършат поради липса на достъп до ресурси или поради непрекъснато прекъсване от други процеси.
- Starvation настъпва, когато „алчните“ (greedy) нишки използват споделените ресурси прекалено дълго и ги правят недостъпни за останалите процеси за дълги периоди. Да предположим например, че обектът предоставя синхронизиран метод, който често отнема много време, за да се върне. Ако една нишка често извиква този метод, други нишки, които също се нуждаят от чест синхронизиран достъп до същия обект, често ще бъдат блокирани. Обикновено гладуването е причинено от прилагането на твърде опростен алгоритъм за съставяне на разписания, по които процесите се изпълняват – не се взима под внимание типът на различните процеси.

#### Пример: задача за философите и макароните

Разглеждаме кръгла маса, на която са седнали 5 философа и се опитват да се нахранят. По средата на масата има купа със спагети, а пред всеки философ има по една чиния и между всеки две чинии има вилица. За да си сложи от спагетите в чинията и да се нахрани, на даден философ са му необходими две вилици едновременно.
- Правим допускането, че философите знаят как да мислят и как да се хранят. Нашата работа е да напишем версия на разпределение на ресурсите (вилиците), в която да са изпълнени следните синхронизационни ограничения:
    - Когато един философ е взел вилица, никой друг не може да я ползва;
    - Да не е възможно да се появи deadlock;
    - Да е възможно повече от един (в нашия случай – повече от двама) философа да се хранят по едно и също време;
    - Да не е възможно философ да гладува дълго време докато чака за вилица.
- Ако всеки философ се опита да вземе първо лявата или дясната вилица, тогава ще настъпи deadlock, защото, за да се нахрани са му нужни две вилици, които да използва едновременно и всеки философ ще чака и ще гладува вечно.
- Може да моделираме лесно тази ситуация с двуделен граф. Процесите ще са философите, а ресурсите ще са вилиците. С ребрата в графа ще обозначаваме необходимостта от ресурс на процес, за да може да си свърши работата. 
- Нека разгледаме горепосочената ситуация, в която всеки философ си е взел лявата вилица и се опитва да вземе дясната. Ще насочим ребрата на графа, за да обозначим това, като посоката ще е от процес към ресурс, а пък обратната посока ще означава, че процесът се опитва да вземе този ресурс, но той е зает. При такова ориентиране на ребрата се получава цикъл и това води до deadlock.
- Нека номерираме множеството от процеси и множеството от ресурси, така че да знаем на кой процес кои ресурси са необходими. След като знаем на кой процес какво множество от ресурси е необходимо, за да си свърши работата, то той ще може да си го сортира и да ги взема по реда на номерата. Тогава алгоритъмът няма да е: „всеки да взима лявата вилица“, а ще е „всеки да взима вилицата с по-малък номер“. Така deadlock няма да настъпи (естествено има малка вероятност за гладуване на някои философи, но deadlock няма да има).


#### Единна йерархична файлова система в UNIX.

В UNIX абстрактната файлова система е кореново дърво. Коренът представя началото на файловата система. Върховете представляват директории, а листата - файлове, като всеки връх (директория) също представлява кореново дърво. Възможно е две файлови системи да бъдат закачени една към друга, като това се осъществява чрез командата mount, която монтира (закача) едната файлова система към другата. Командата unmount служи за откачане на една файлова система от друга. Има някои специални директории, които присъстват във всяка файлова система (напр. /dev , /etc, /tmp), като когато добавим някакво външно устройство (напр. когато свържем флашка към компютъра), това устройство се появява във файловата система. Към всеки файл, освен името и съдържанието, се асоциират и други атрибути - тип на файла ("-" - обикновени файлове, "d" - директории, "c" - символно устройство/character special device (напр. клавиатурата), "b" - блоково устройство/block special device – външно у-во, което съхранява масив от байтове, "p" - именувана тръба (FIFO), "s" - socket/конектор – крайна точка за комуникация), права за достъп, потребител, потребителска група, размер, дата на промяна, дата на създаване и др. В Linux тези атрибути се пазят отделно от самия файл, което от една страна прави достъпа до тях по-бавен, но от друга страна дава възможност за съществуването на т.нар. hardlinks, т.е. за създаване на друго име на файла (файлът ще бъде същия, понеже ще сочи към същите атрибути, но името му може да бъде различно). По този начин, файлът ще бъде изтрит от паметта чак когато всички hardlinks към него се изтрият.

#### Файлове и директори
- Файлове: в UNIX всичко се разглежда като файл - включително обикновените текствои файлове, директории, устройства, и дори сокети. Всеки файл в системата има име, тип, размер и други метаданни като права за достъп и времеви маркери. Обикновените файлове съдържат данни, програми или текст. Пример за обикновен файл е такстов файл като notes.txt или изпълним файл като program.
- Директории: директориите са специален тип файлове, които съдържат други файлове и поддиректории. Те играят ролята на контейнер, който организира файловете в логическа структура. Директория може да съдържа хиляди файлове и поддиректории, всяка от които може да съдържа още файлове и поддиректории, формирайки йерархия. 

#### Тема 10