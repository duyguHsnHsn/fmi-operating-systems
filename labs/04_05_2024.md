# Notes

- for in bash means "for each work", and if we have filename with spaces for break really easily
- for is not used much to read files, we use while read generally
- when we use cat instead of giving the file input to some commands we get less info since the second command
does not know that it is working with a file
- check commands like sha256sum since they might be really useful for exercises with file content


### 2017-se-04
Напишете shell script, който получава задължителен първи позиционен параметър – директория
и незадължителен втори – име на файл. Скриптът трябва да намира в подадената директория и нейните
под-директории всички symlink-ове и да извежда (при подаден аргумент файл – добавяйки към файла,
а ако не е – на стандартния изход) за тях следната информация:

- ако destination-a съществува – името на symlink-а - > името на destination-а;
- броя на symlink-овете, чийто destination не съществува.

Примерен изход:
````text
lbaz -> /foo/bar/baz
lqux -> ../../../qux
lquux -> /foo/quux
Broken symlinks: 34
````


````shell

if [[ "${#}" -lt 1 || "${#}" -gt 2 ]]; then
  echo "The script needs at least one argument (path to directory) and optionally second one (file name)."
  exit 1
fi 

if [[ ! -d  "${1}" ]]; then
  echo "The first argument should be a directory."
  exit 1
fi 

out="/dev/stdout" # by default we work with the standard stdout 

if [[ "${#}" -eq 2 ]]; then
  out="${2}"
fi 

broken=0

while read file; do 
  if [[ -e "${file}" ]]; then
    echo "$(basename ${file}) -> $(readlink "${file}")" >> "${out}"
  else
    broken=$((broken+1))
  fi
done < <(find "${1}" -type l 2>/dev/null) # we add 2>/dev/null to not print the error (it is not required)

echo "Broken symlink count: ${broken}" >> "${out}"

exit 0
````

### 2023-se-01

Напишете скрипт, който цензурира всички срещания на “забранени” думи в дадени текстове.
Примерно извикване: ./redact.sh bad_words.lst ./my_texts .
Първият аргумент на скрипта е име на текстов файл, съдържащ по една забранена дума на ред:
````text
cake
cakes
shake
banana
pine_apple42
shakinator
````
Вторият аргумент е име на директория: интересуват ни всички файлове в нея и в нейните поддиректории,
чиито имена завършват на .txt.

Скриптът ви трябва да подмени всички срещания на забранени думи във въпросните файлове с брой
звездички, съответстващ на дължината на думата. Подменят се само цели срещания на думи.
Например, ако имаме файл . /my_texts/shake.txt със съдържание:

to make banana shake, we start by blending four bananas.

след изпълнение на скрипта, съдържанието му трябва да е:

to make ****** ***** , we start by blending four bananas.

30

Под “дума” разбираме последователност от букви, цифри и долни черти.
За улеснение, може да приемете, че разглеждаме само малки букви (никъде не се срещат главни
букви).
За бонус точки: премахнете улесненито, правейки операцията по цензуриране case-insensitive (файлът
със забранени думи пак съдържа само малки букви, но в текстовете могат да се срещнат варианти на
думите с произволни комбинации от малки и главни букви): ако в примерния текст се срещне думата
B a N a N a , тя трябва да бъде заменена с * * * * * * , защото b a n a n a е забранена дума.

This is a simple solution, we can optimise the loops and make it faster. 

````shell
if [[ "${#}" -ne 2 ]]; then
  echo "The script needs two arguments."
  exit 1
fi 

if [[ ! -d  "${2}" ]]; then
  echo "The second argument should be a directory."
  exit 1
fi 

# add check for first arg

while read file; do
  while read word; do 
    replace="$(echo "${word} | tr '[a-zA-Z0-9_]' '*'")"
    sed -E -i "s/\b${word}\b/${replace}/g" "${file}" # \b checks for whitespace, line start and end 
  done < "${1}"
done < <(find "${2} -type f -name '*.txt' 2>/dev/null")

````