# Notes from 19th and 26th of April


- We will be working with a lot of binary files; because chars are read differently according to how they are represented UTF-8, ASCII, etc.
- Good to use int_16_t, int32_t instead of just int since we know exactly how many digits we will have
- bools are added with the header stdbool.h (bools are considered "unnecessary" in C )
- learn get_file_size
- learn reading binary output with uint8_t, uint16_t, etc. 



### Example code:

```c
#include <stdint.h>
#include <stdbool.h>


typedef struct __attribute__((packed)) test { 
    uint8_t int1;
    int32_t int3;
    uint8_t int2;
}

int main(){
    struct test my_struct;
    test my_struct;

    struct {
        uint8_t test;
    } inline_struct;

    return file_stats.st_Size
}
```

### 2016-se-02

```c
#include <stdint.h>
#include <error.h>

typedef struct pair {
    uint32_t int1;
    uint32_t int2;

}

int get_fle_size(int fd) {
    struct stat file_stats;
    if (fstat(fd, &file_stats) == -1 ){
        err(1, "stat");
    }
    return 
}


int main(int argc, char* argv[]){
    if (argc != 4){
        errx(1, "wrogn number of args")
    }

    int f1 = open(argv[1], O_RDONLY);
    if (f1 == -1){
        err(1, "%s", argv[1])
    }

    int f2 = open(argv[2], O_RDONLY);
    if (f2 == -1){
        err(1, "%s", argv[2])
    }

    int f3 = open(argv[3], O_WRONLY | O_TRUNC | O_CREAT , S_TRUSH | S_TWUSR);
    if (f3 == -1){
        err(1, "%s", argv[3])
    }

    int f1_size = get_file_size(f1);
    int f2_size = get_file_size(f2);

    if (f1_size % 2*(sizeof(uint32_t)) != 0) {
        err(1, "%s: bad file", argv[1])
    }

    if (f2_size % (sizeof(uint32_t)) != 0) {
        err(1, "%s: bad file", argv[2])
    }

    pair p;
    ssize_t read_size;

    while ((read_size = read(f1, &p, sizeof(p))) > 0){

        if(p.offset * sizeof(uint32_t) >= f2_size || (p.offset + p.lenght) * sizeof(uint32_t) >= f2_size) {
            errx(2, "invalid offset %d", p.offset)
        }

        if (lseek(f2, p.offset * sizeof(uint32_t), SEEK_SET) == -1){
            err(2, "can't seek")
        }

        uint32_t num;

        for (uint32_t i=0; i < p.lenght; i++){
            if(read(f2, &num, sizeof(num)) != sizeof(num)){
                err(3, "can't read");
            }
            if(write(f3, &num, sizeof(num)) == -1){
                err(3, "can't write");
            }
        }
    }

    close(f1)
    close(f2)
    close(f3)
}

```

### 2017-se-01

```c
#include <stdint.h>
#include <error.h>

typedef struct diff {
    uint16_t offset;
    uint8_t original;
    uint8_t new;

}

int get_fle_size(int fd) {
    struct stat file_stats;
    if (fstat(fd, &file_stats) == -1 ){
        err(1, "stat");
    }
    return 
}


int main(int argc, char* argv[]){
    if (argc != 4){
        errx(1, "wrogn number of args")
    }

    int f1 = open(argv[1], O_RDONLY);
    if (f1 == -1){
        err(1, "%s", argv[1])
    }

    int f2 = open(argv[2], O_RDONLY);
    if (f2 == -1){
        err(1, "%s", argv[2])
    }

    int patch = open(argv[3], O_WRONLY | O_TRUNC | O_CREAT , S_TRUSH | S_TWUSR);
    if (patch == -1){
        err(1, "%s", argv[3])
    }

    int f1_size = get_file_size(f1);
    int f2_size = get_file_size(f2);

    if (f1_size != f2_size) {
        err(1, "%s and %s: different sizes", argv[1], argv[2])
    }

    if (f1_size > UINT16_MAX) {
        err(1, "%s: bad file", argv[2])
    }

    char original_byte;
    char new_byte;
    ssize_t read_size;

    uint16_t offset;

    while ((read_size = read(f1, &original_byte, sizeof(uint8_t))) > 0){
        if (read(f2, &new_byte, sizeof(uint8_t)) == -1 ){
            err(4, "can't read")
        }

        if (original_byte != new_byte) {
            diff d;
            d.offset = current_offset;
            d.original = original_byte;
            d.new = new_byte;

        }

        if (read_size == -1){
            err(4, "can't read")
        }

        current_offset++;
    }

    close(f1);
    close(f2);
    close(patch);

    return 0;
```

### 2023-se-02

```c


```