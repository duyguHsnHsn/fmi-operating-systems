# Notes from 32nd of June


### 2020-SE-03 (–ó–∞–¥. 103)

–ù–∞–ø–∏—à–µ—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–∞ –Ω–∞ C, –∫–æ—è—Ç–æ –ø—Ä–∏–µ–º–∞ –µ–¥–∏–Ω –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–µ–Ω –ø–æ–∑–∏—Ü–∏–æ–Ω–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—ä—Ä -
–∏–º–µ –Ω–∞ —Ñ–∞–π–ª. –§–∞–π–ª—ä—Ç —Å–µ —Å—ä—Å—Ç–æ–∏ –æ—Ç –Ω–µ –ø–æ–≤–µ—á–µ –æ—Ç 8 –Ω–∞—Ä–µ–¥–µ–Ω–∏ —Ç—Ä–æ–π–∫–∏ –µ–ª–µ–º–µ–Ω—Ç–∏:
- –∏–º–µ –Ω–∞ —Ñ–∞–π–ª ‚Äì —Ç–æ—á–Ω–æ 8 –±–∞–π—Ç–∞, –ø–æ—Å–ª–µ–¥–Ω–∏—è—Ç –æ—Ç –∫–æ–∏—Ç–æ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –µ 0x00. –ê–∫–æ –∏–º–µ—Ç–æ –µ –ø–æ-–∫—ä—Å–æ –æ—Ç
7 –∑–Ω–∞–∫–∞, –∏–∑–ª–∏—à–Ω–∏—Ç–µ –±–∞–π—Ç–æ–≤–µ —Å–∞ 0x00;
- offset ‚Äì uint32_t, –∫–æ–π—Ç–æ –¥–∞–≤–∞ –ø–æ—Ä–µ–¥–µ–Ω –Ω–æ–º–µ—Ä –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç (—Å–ø—Ä—è–º–æ ùëÅ0
) –≤—ä–≤ —Ñ–∞–π–ª–∞;
- length ‚Äì uint32_t, –∫–æ–π—Ç–æ –¥–∞–≤–∞ –±—Ä–æ–π –µ–ª–µ–º–µ–Ω—Ç–∏.


–ó–∞ –≤—Å—è–∫–∞ –Ω–∞—Ä–µ–¥–µ–Ω–∞ —Ç—Ä–æ–π–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø—É—Å–Ω–µ child –ø—Ä–æ—Ü–µ—Å, –∫–æ–π—Ç–æ –¥–∞ XOR-–Ω–µ (–æ–±—Ä–∞–±–æ—Ç–∏ —Å –∏–∑–∫–ª—é—á–≤–∞—â–æ–∏–ª–∏) –µ–ª–µ–º–µ–Ω—Ç–∏—Ç–µ (uint16_t) –æ—Ç —Å—ä–æ—Ç–≤–µ—Ç–Ω–∏—è —Ñ–∞–π–ª –µ–¥–∏–Ω —Å—ä—Å –¥—Ä—É–≥, –∏ –¥–∞ –≤—ä—Ä–Ω–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –Ω–∞ parent –ø—Ä–æ—Ü–µ—Å–∞,
–∫–æ–π—Ç–æ –æ—Ç —Å–≤–æ—è —Å—Ç—Ä–∞–Ω–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ XOR-–Ω–µ –≤—Å–∏—á–∫–∏ –ø–æ–ª—É—á–µ–Ω–∏—Ç–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –∏ –¥–∞ –∏–∑–≤–µ–¥–µ –ø–æ–ª—É—á–µ–Ω–æ—Ç–æ —á–∏—Å–ª–æ –≤
—Å–ª–µ–¥–Ω–∏—è —Ñ–æ—Ä–º–∞—Ç:
`result:573B`

–ó–∞–±–µ–ª–µ–∂–∫–∞: –° –ø—ä–ª–µ–Ω –±—Ä–æ–π —Ç–æ—á–∫–∏ —Å–µ –æ—Ü–µ–Ω—è–≤–∞—Ç —Ä–µ—à–µ–Ω–∏—è, –≤ –∫–æ–∏—Ç–æ child –ø—Ä–æ—Ü–µ—Å–∏—Ç–µ —Ä–∞–±–æ—Ç—è—Ç –ø–∞—Ä–∞–ª–µ–ª–Ω–æ

```c
#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <stdint.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <stdio.h>

typedef struct IndexEntry {
	char filename[8];
	uint32_t offset;
	uint32_t length;
} IndexEntry;

void xorFile(IndexEntry* entry, int result_fd);

void xorFile(IndexEntry* entry, int result_fd) {
	int file = open(entry->filename, O_RDONLY);
	if(file == -1) { err(2, "open %s", entry->filename); }

	struct stat st;
	if(fstat(file, &st) == -1) { err(2, "stat %s", entry->filename); }

	// XXX: Sample data doesn't actually follow this rule.
	// if(st.st_size % sizeof(uint16_t) != 0) {
	// 	errx(2, "%s: bad file size", entry->filename);
	// }

	if((uint32_t)st.st_size < sizeof(uint16_t) * (entry->offset + entry->length)) {
		errx(2, "%s: offset would go past EOF", entry->filename);
	}

	if(lseek(file, sizeof(uint16_t) * entry->offset, SEEK_SET) == -1) {
		err(2, "lseek");
	}

	uint16_t result = 0;
	ssize_t read_size = 0;
	uint16_t element;

	size_t num_elements = 0;

	while((num_elements < entry->length) && (read_size = read(file, &element, sizeof(element))) > 0) {
		result ^= element;
		num_elements++;
	}

	if(read_size < 0) {
		err(2, "read");
	}

	close(file);

	if(write(result_fd, &result, sizeof(result)) == -1) {
		err(2, "write");
	}
}

int main(int argc, char* argv[]) {
	if(argc != 2) {
		errx(1, "not enough args");
	}

	int index = open(argv[1], O_RDONLY);
	if(index == -1) { err(1, "%s", argv[1]); }

	struct stat st;
	if(fstat(index, &st) == -1) { err(1, "%s: stat", argv[1]); }

	if(st.st_size % sizeof(IndexEntry) != 0 || (uint8_t)st.st_size > 8 * sizeof(IndexEntry)) {
        errx(1, "wrong index format");
    }

	int pipe_fd[2];
	if(pipe(pipe_fd) == -1) { err(1, "pipe"); }

	IndexEntry entry;
	ssize_t read_size;

	int child_count = 0;

	while((read_size = read(index, &entry, sizeof(entry))) > 0) {
		child_count++;

		pid_t pid = fork();
		if(pid == -1) { err(1, "fork"); }

		if(pid == 0) {
			// worker process
			close(index);
			close(pipe_fd[0]);

			xorFile(&entry, pipe_fd[1]);

#ifdef DEBUG
			dprintf(2, "child %d handling %s done\n", getpid(), entry.filename);
#endif

			close(pipe_fd[1]);
			exit(0);
		}

#ifdef DEBUG
		dprintf(2, "file name: %s, handled by pid: %d\n", entry.filename, pid);
#endif
	}

	if(read_size < 0) {
		err(1, "read from index");
	}

	// (!): Will deadlock without this. The read() below expects all
	//      write ends of the pipe to be closed.
	close(pipe_fd[1]);

	uint16_t result = 0;
	uint16_t element;

	while((read_size = read(pipe_fd[0], &element, sizeof(element))) > 0) {
		result ^= element;
	}

	if(read_size < 0) {
		err(1, "read from pipes");
	}

	close(pipe_fd[0]);

	int status;

	for(int i = 0; i < child_count; i++) {
		pid_t pid;
		if((pid = wait(&status)) == -1) { err(1, "wait"); }

		if (WIFEXITED(status)) {
#ifdef DEBUG
			dprintf(2, "child %d has exited\n", pid);
#endif

			if(WEXITSTATUS(status) != 0) {
				warnx("child %d exited with code %d", pid, WEXITSTATUS(status));
			}
		} else {
			warnx("child %d was killed", pid);
		}
	}

	dprintf(1, "result: %.4X\n", result);

	close(index);
	return 0;
```

### –ó–∞–¥. 105 2022-IN-01

–í–∞—à–∏ –∫–æ–ª–µ–≥–∏ - –∞—Å–∏—Å—Ç–µ–Ω—Ç–∏ –ø–æ –û–° –∏–º–∞—Ç –Ω—É–∂–¥–∞ –æ—Ç –¥–µ–º–æ—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –Ω–∞ C, –∫–æ—è—Ç–æ
–¥–∞ —Å–ª—É–∂–∏ –∫–∞—Ç–æ –ø—Ä–∏–º–µ—Ä –∑–∞ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ—Å—Ç –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–∞ –ø—Ä–æ—Ü–µ—Å–∏. –ù–∞–ø–∏—à–µ—Ç–µ —Ç–∞–∫–∞–≤–∞ –ø—Ä–æ–≥—Ä–∞–º–∞,
–ø—Ä–∏–µ–º–∞—â–∞ –¥–≤–∞ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—ä—Ä–∞ ‚Äì –µ–¥–Ω–æ—Ü–∏—Ñ—Ä–µ–Ω–∏ —á–∏—Å–ª–∞. –ü—Ä–∏–º–µ—Ä–Ω–æ –∏–∑–≤–∏–∫–≤–∞–Ω–µ:
`./main N D`


–û–±—â –∞–ª–≥–æ—Ä–∏—Ç—ä–º –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞:
- –Ω–∞—á–∞–ª–Ω–∏—è—Ç (—Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏) –ø—Ä–æ—Ü–µ—Å —Å—ä–∑–¥–∞–≤–∞ –ø—Ä–æ—Ü–µ—Å-–Ω–∞—Å–ª–µ–¥–Ω–∏–∫
- ùëÅ –Ω–∞ –±—Ä–æ–π –ø—ä—Ç–∏ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞:
* —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏—è—Ç –ø—Ä–æ—Ü–µ—Å –∏–∑–≤–µ–∂–¥–∞ –Ω–∞ stdout –Ω–∏–∑–∞ ‚ÄúD I N G ‚Äù
* –ø—Ä–æ—Ü–µ—Å—ä—Ç-–Ω–∞—Å–ª–µ–¥–Ω–∏–∫ –∏–∑–≤–µ–∂–¥–∞ –Ω–∞ stdout –Ω–∏–∑–∞ ‚ÄúD O N G ‚Äù
* —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏—è—Ç –ø—Ä–æ—Ü–µ—Å –∏–∑—á–∞–∫–≤–∞ ùê∑ —Å–µ–∫—É–Ω–¥–∏


–ì–∞—Ä–∞–Ω—Ç–∏—Ä–∞–π—Ç–µ, —á–µ:
- –ø—Ä–æ—Ü–µ—Å—ä—Ç-–Ω–∞—Å–ª–µ–¥–Ω–∏–∫ –≤–∏–Ω–∞–≥–∏ –∏–∑–≤–µ–∂–¥–∞ ‚ÄúD O N G ‚Äù —Å–ª–µ–¥ –∫–∞—Ç–æ —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏—è –ø—Ä–æ—Ü–µ—Å –µ –∏–∑–≤–µ–ª ‚ÄúD I N G ‚Äù
- —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏—è—Ç –ø—Ä–æ—Ü–µ—Å –≤–∏–Ω–∞–≥–∏ –∑–∞–ø–æ—á–≤–∞ –∏–∑—á–∞–∫–≤–∞–Ω–µ—Ç–æ —Å–ª–µ–¥ –∫–∞—Ç–æ –ø—Ä–æ—Ü–µ—Å–∞-–Ω–∞—Å–ª–µ–¥–Ω–∏–∫ –µ –∏–∑–≤–µ–ª ‚ÄúD O N G ‚Äù


–ó–∞–±–µ–ª–µ–∂–∫–∞: –ó–∞ –∏–∑—á–∞–∫–≤–∞–Ω–µ—Ç–æ –ø–æ–≥–ª–µ–¥–Ω–µ—Ç–µ sleep(3).

```c
#define DEBUG

#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <stdint.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>

#ifdef DEBUG
#include <stdio.h>
#endif

const char* DING = "DING ";
const char* DONG = "DONG\n";

void handleParent(int, int, int, int);
void handleChild(int, int);

void handleParent(int N, int D, int to_child, int from_child) {
	for(int i = 1; i <= N; i++) {
#ifdef DEBUG
		dprintf(1, "[%d ", getpid());
#endif

		if(write(1, DING, strlen(DING)) == -1) { err(1, "write (ding)"); }

#ifdef DEBUG
		dprintf(1, "]\n");
#endif

		int data = 0;
		if(write(to_child, &data, sizeof(data)) == -1) { err(1, "write (to child)"); }

		// EOF here is an error, the child shouldn't close its pipe
		// until this function returns in the parent
		int dummy;
		if(read(from_child, &dummy, sizeof(dummy)) <= 0) { err(1, "read (from child)"); }

		sleep(D);
	}
}

void handleChild(int from_parent, int to_parent) {
	ssize_t read_size;
	int data;

	// EOF here is expected, the parent will close its pipe
	// when the loop has finished
	while((read_size = read(from_parent, &data, sizeof(data))) > 0) {
#ifdef DEBUG
		dprintf(1, "[%d ", getpid());
#endif

		if(write(1, DONG, strlen(DONG)) == -1) { err(2, "write (dong)"); }

#ifdef DEBUG
		dprintf(1, "]\n");
#endif

		int dummy = 0;
		if(write(to_parent, &dummy, sizeof(dummy)) == -1) { err(2, "write (to parent)"); }
	}

	if(read_size < 0) {
		err(2, "read (from parent)");
	}
}

int main(int argc, char* argv[]) {
	if(argc != 3) {
		errx(1, "not enough args");
	}

	char* endptr;

	int N = strtol(argv[1], &endptr, 10);

	if(*argv[1] == '\0' || *endptr != '\0') {
		errx(1, "N must be an int, got: %s", argv[1]);
	}

	if(N < 0) {
		errx(1, "N must be non-negative");
	}

	int D = strtol(argv[2], &endptr, 10);

	if(*argv[2] == '\0' || *endptr != '\0') {
		errx(1, "D must be an int, got: %s", argv[2]);
	}

	if(D < 0) {
		errx(1, "D must be non-negative");
	}

	int parent_to_child[2];
	if(pipe(parent_to_child) == -1) { err(1, "pipe"); }

	int child_to_parent[2];
	if(pipe(child_to_parent) == -1) { err(1, "pipe"); }

	pid_t pid = fork();
	if(pid == -1) { err(1, "fork"); }

	if(pid == 0) {
		// child
		close(parent_to_child[1]);
		close(child_to_parent[0]);
		
		handleChild(parent_to_child[0], child_to_parent[1]);

		close(parent_to_child[0]);
		close(child_to_parent[1]);

		exit(0);
	}

	// parent
	close(parent_to_child[0]);
	close(child_to_parent[1]);

	handleParent(N, D, parent_to_child[1], child_to_parent[0]);
	
	close(parent_to_child[1]);
	close(child_to_parent[0]);

	int status;
	if(wait(&status) == -1) { err(1, "wait"); }
	if(!WIFEXITED(status)) {
		errx(1, "child was killed");
	}

	return 0;
}


```