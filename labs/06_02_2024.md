# Notes from 32nd of June


### 2020-SE-03 (–ó–∞–¥. 103)

–ù–∞–ø–∏—à–µ—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–∞ –Ω–∞ C, –∫–æ—è—Ç–æ –ø—Ä–∏–µ–º–∞ –µ–¥–∏–Ω –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–µ–Ω –ø–æ–∑–∏—Ü–∏–æ–Ω–µ–Ω –ø–∞—Ä–∞–º–µ—Ç—ä—Ä -
–∏–º–µ –Ω–∞ —Ñ–∞–π–ª. –§–∞–π–ª—ä—Ç —Å–µ —Å—ä—Å—Ç–æ–∏ –æ—Ç –Ω–µ –ø–æ–≤–µ—á–µ –æ—Ç 8 –Ω–∞—Ä–µ–¥–µ–Ω–∏ —Ç—Ä–æ–π–∫–∏ –µ–ª–µ–º–µ–Ω—Ç–∏:
- –∏–º–µ –Ω–∞ —Ñ–∞–π–ª ‚Äì —Ç–æ—á–Ω–æ 8 –±–∞–π—Ç–∞, –ø–æ—Å–ª–µ–¥–Ω–∏—è—Ç –æ—Ç –∫–æ–∏—Ç–æ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –µ 0x00. –ê–∫–æ –∏–º–µ—Ç–æ –µ –ø–æ-–∫—ä—Å–æ –æ—Ç
7 –∑–Ω–∞–∫–∞, –∏–∑–ª–∏—à–Ω–∏—Ç–µ –±–∞–π—Ç–æ–≤–µ —Å–∞ 0x00;
- offset ‚Äì uint32_t, –∫–æ–π—Ç–æ –¥–∞–≤–∞ –ø–æ—Ä–µ–¥–µ–Ω –Ω–æ–º–µ—Ä –Ω–∞ –µ–ª–µ–º–µ–Ω—Ç (—Å–ø—Ä—è–º–æ ùëÅ0
) –≤—ä–≤ —Ñ–∞–π–ª–∞;
- length ‚Äì uint32_t, –∫–æ–π—Ç–æ –¥–∞–≤–∞ –±—Ä–æ–π –µ–ª–µ–º–µ–Ω—Ç–∏.


–ó–∞ –≤—Å—è–∫–∞ –Ω–∞—Ä–µ–¥–µ–Ω–∞ —Ç—Ä–æ–π–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ –ø—É—Å–Ω–µ child –ø—Ä–æ—Ü–µ—Å, –∫–æ–π—Ç–æ –¥–∞ XOR-–Ω–µ (–æ–±—Ä–∞–±–æ—Ç–∏ —Å –∏–∑–∫–ª—é—á–≤–∞—â–æ–∏–ª–∏) –µ–ª–µ–º–µ–Ω—Ç–∏—Ç–µ (uint16_t) –æ—Ç —Å—ä–æ—Ç–≤–µ—Ç–Ω–∏—è —Ñ–∞–π–ª –µ–¥–∏–Ω —Å—ä—Å –¥—Ä—É–≥, –∏ –¥–∞ –≤—ä—Ä–Ω–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∞ –Ω–∞ parent –ø—Ä–æ—Ü–µ—Å–∞,
–∫–æ–π—Ç–æ –æ—Ç —Å–≤–æ—è —Å—Ç—Ä–∞–Ω–∞ —Ç—Ä—è–±–≤–∞ –¥–∞ XOR-–Ω–µ –≤—Å–∏—á–∫–∏ –ø–æ–ª—É—á–µ–Ω–∏—Ç–µ —Ä–µ–∑—É–ª—Ç–∞—Ç–∏ –∏ –¥–∞ –∏–∑–≤–µ–¥–µ –ø–æ–ª—É—á–µ–Ω–æ—Ç–æ —á–∏—Å–ª–æ –≤
—Å–ª–µ–¥–Ω–∏—è —Ñ–æ—Ä–º–∞—Ç:
`result:573B`

–ó–∞–±–µ–ª–µ–∂–∫–∞: –° –ø—ä–ª–µ–Ω –±—Ä–æ–π —Ç–æ—á–∫–∏ —Å–µ –æ—Ü–µ–Ω—è–≤–∞—Ç —Ä–µ—à–µ–Ω–∏—è, –≤ –∫–æ–∏—Ç–æ child –ø—Ä–æ—Ü–µ—Å–∏—Ç–µ —Ä–∞–±–æ—Ç—è—Ç –ø–∞—Ä–∞–ª–µ–ª–Ω–æ

```c
#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <stdint.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <stdio.h>

typedef struct IndexEntry {
	char filename[8];
	uint32_t offset;
	uint32_t length;
} IndexEntry;

void xorFile(IndexEntry* entry, int result_fd);

void xorFile(IndexEntry* entry, int result_fd) {
	int file = open(entry->filename, O_RDONLY);
	if(file == -1) { err(2, "open %s", entry->filename); }

	struct stat st;
	if(fstat(file, &st) == -1) { err(2, "stat %s", entry->filename); }

	// XXX: Sample data doesn't actually follow this rule.
	// if(st.st_size % sizeof(uint16_t) != 0) {
	// 	errx(2, "%s: bad file size", entry->filename);
	// }

	if((uint32_t)st.st_size < sizeof(uint16_t) * (entry->offset + entry->length)) {
		errx(2, "%s: offset would go past EOF", entry->filename);
	}

	if(lseek(file, sizeof(uint16_t) * entry->offset, SEEK_SET) == -1) {
		err(2, "lseek");
	}

	uint16_t result = 0;
	ssize_t read_size = 0;
	uint16_t element;

	size_t num_elements = 0;

	while((num_elements < entry->length) && (read_size = read(file, &element, sizeof(element))) > 0) {
		result ^= element;
		num_elements++;
	}

	if(read_size < 0) {
		err(2, "read");
	}

	close(file);

	if(write(result_fd, &result, sizeof(result)) == -1) {
		err(2, "write");
	}
}

int main(int argc, char* argv[]) {
	if(argc != 2) {
		errx(1, "not enough args");
	}

	int index = open(argv[1], O_RDONLY);
	if(index == -1) { err(1, "%s", argv[1]); }

	struct stat st;
	if(fstat(index, &st) == -1) { err(1, "%s: stat", argv[1]); }

	if(st.st_size % sizeof(IndexEntry) != 0 || (uint8_t)st.st_size > 8 * sizeof(IndexEntry)) {
        errx(1, "wrong index format");
    }

	int pipe_fd[2];
	if(pipe(pipe_fd) == -1) { err(1, "pipe"); }

	IndexEntry entry;
	ssize_t read_size;

	int child_count = 0;

	while((read_size = read(index, &entry, sizeof(entry))) > 0) {
		child_count++;

		pid_t pid = fork();
		if(pid == -1) { err(1, "fork"); }

		if(pid == 0) {
			// worker process
			close(index);
			close(pipe_fd[0]);

			xorFile(&entry, pipe_fd[1]);

#ifdef DEBUG
			dprintf(2, "child %d handling %s done\n", getpid(), entry.filename);
#endif

			close(pipe_fd[1]);
			exit(0);
		}

#ifdef DEBUG
		dprintf(2, "file name: %s, handled by pid: %d\n", entry.filename, pid);
#endif
	}

	if(read_size < 0) {
		err(1, "read from index");
	}

	// (!): Will deadlock without this. The read() below expects all
	//      write ends of the pipe to be closed.
	close(pipe_fd[1]);

	uint16_t result = 0;
	uint16_t element;

	while((read_size = read(pipe_fd[0], &element, sizeof(element))) > 0) {
		result ^= element;
	}

	if(read_size < 0) {
		err(1, "read from pipes");
	}

	close(pipe_fd[0]);

	int status;

	for(int i = 0; i < child_count; i++) {
		pid_t pid;
		if((pid = wait(&status)) == -1) { err(1, "wait"); }

		if (WIFEXITED(status)) {
#ifdef DEBUG
			dprintf(2, "child %d has exited\n", pid);
#endif

			if(WEXITSTATUS(status) != 0) {
				warnx("child %d exited with code %d", pid, WEXITSTATUS(status));
			}
		} else {
			warnx("child %d was killed", pid);
		}
	}

	dprintf(1, "result: %.4X\n", result);

	close(index);
	return 0;
```

### –ó–∞–¥. 105 2022-IN-01

–í–∞—à–∏ –∫–æ–ª–µ–≥–∏ - –∞—Å–∏—Å—Ç–µ–Ω—Ç–∏ –ø–æ –û–° –∏–º–∞—Ç –Ω—É–∂–¥–∞ –æ—Ç –¥–µ–º–æ—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –Ω–∞ C, –∫–æ—è—Ç–æ
–¥–∞ —Å–ª—É–∂–∏ –∫–∞—Ç–æ –ø—Ä–∏–º–µ—Ä –∑–∞ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ—Å—Ç –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–∞ –ø—Ä–æ—Ü–µ—Å–∏. –ù–∞–ø–∏—à–µ—Ç–µ —Ç–∞–∫–∞–≤–∞ –ø—Ä–æ–≥—Ä–∞–º–∞,
–ø—Ä–∏–µ–º–∞—â–∞ –¥–≤–∞ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–Ω–∏ –ø–∞—Ä–∞–º–µ—Ç—ä—Ä–∞ ‚Äì –µ–¥–Ω–æ—Ü–∏—Ñ—Ä–µ–Ω–∏ —á–∏—Å–ª–∞. –ü—Ä–∏–º–µ—Ä–Ω–æ –∏–∑–≤–∏–∫–≤–∞–Ω–µ:
`./main N D`


–û–±—â –∞–ª–≥–æ—Ä–∏—Ç—ä–º –Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞:
- –Ω–∞—á–∞–ª–Ω–∏—è—Ç (—Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏) –ø—Ä–æ—Ü–µ—Å —Å—ä–∑–¥–∞–≤–∞ –ø—Ä–æ—Ü–µ—Å-–Ω–∞—Å–ª–µ–¥–Ω–∏–∫
- ùëÅ –Ω–∞ –±—Ä–æ–π –ø—ä—Ç–∏ —Å–µ –∏–∑–ø—ä–ª–Ω—è–≤–∞:
* —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏—è—Ç –ø—Ä–æ—Ü–µ—Å –∏–∑–≤–µ–∂–¥–∞ –Ω–∞ stdout –Ω–∏–∑–∞ ‚ÄúD I N G ‚Äù
* –ø—Ä–æ—Ü–µ—Å—ä—Ç-–Ω–∞—Å–ª–µ–¥–Ω–∏–∫ –∏–∑–≤–µ–∂–¥–∞ –Ω–∞ stdout –Ω–∏–∑–∞ ‚ÄúD O N G ‚Äù
* —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏—è—Ç –ø—Ä–æ—Ü–µ—Å –∏–∑—á–∞–∫–≤–∞ ùê∑ —Å–µ–∫—É–Ω–¥–∏


–ì–∞—Ä–∞–Ω—Ç–∏—Ä–∞–π—Ç–µ, —á–µ:
- –ø—Ä–æ—Ü–µ—Å—ä—Ç-–Ω–∞—Å–ª–µ–¥–Ω–∏–∫ –≤–∏–Ω–∞–≥–∏ –∏–∑–≤–µ–∂–¥–∞ ‚ÄúD O N G ‚Äù —Å–ª–µ–¥ –∫–∞—Ç–æ —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏—è –ø—Ä–æ—Ü–µ—Å –µ –∏–∑–≤–µ–ª ‚ÄúD I N G ‚Äù
- —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏—è—Ç –ø—Ä–æ—Ü–µ—Å –≤–∏–Ω–∞–≥–∏ –∑–∞–ø–æ—á–≤–∞ –∏–∑—á–∞–∫–≤–∞–Ω–µ—Ç–æ —Å–ª–µ–¥ –∫–∞—Ç–æ –ø—Ä–æ—Ü–µ—Å–∞-–Ω–∞—Å–ª–µ–¥–Ω–∏–∫ –µ –∏–∑–≤–µ–ª ‚ÄúD O N G ‚Äù


–ó–∞–±–µ–ª–µ–∂–∫–∞: –ó–∞ –∏–∑—á–∞–∫–≤–∞–Ω–µ—Ç–æ –ø–æ–≥–ª–µ–¥–Ω–µ—Ç–µ sleep(3).

```c
#define DEBUG

#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <stdint.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>

#ifdef DEBUG
#include <stdio.h>
#endif

const char* DING = "DING ";
const char* DONG = "DONG\n";

void handleParent(int, int, int, int);
void handleChild(int, int);

void handleParent(int N, int D, int to_child, int from_child) {
	for(int i = 1; i <= N; i++) {
#ifdef DEBUG
		dprintf(1, "[%d ", getpid());
#endif

		if(write(1, DING, strlen(DING)) == -1) { err(1, "write (ding)"); }

#ifdef DEBUG
		dprintf(1, "]\n");
#endif

		int data = 0;
		if(write(to_child, &data, sizeof(data)) == -1) { err(1, "write (to child)"); }

		// EOF here is an error, the child shouldn't close its pipe
		// until this function returns in the parent
		int dummy;
		if(read(from_child, &dummy, sizeof(dummy)) <= 0) { err(1, "read (from child)"); }

		sleep(D);
	}
}

void handleChild(int from_parent, int to_parent) {
	ssize_t read_size;
	int data;

	// EOF here is expected, the parent will close its pipe
	// when the loop has finished
	while((read_size = read(from_parent, &data, sizeof(data))) > 0) {
#ifdef DEBUG
		dprintf(1, "[%d ", getpid());
#endif

		if(write(1, DONG, strlen(DONG)) == -1) { err(2, "write (dong)"); }

#ifdef DEBUG
		dprintf(1, "]\n");
#endif

		int dummy = 0;
		if(write(to_parent, &dummy, sizeof(dummy)) == -1) { err(2, "write (to parent)"); }
	}

	if(read_size < 0) {
		err(2, "read (from parent)");
	}
}

int main(int argc, char* argv[]) {
	if(argc != 3) {
		errx(1, "not enough args");
	}

	char* endptr;

	int N = strtol(argv[1], &endptr, 10);

	if(*argv[1] == '\0' || *endptr != '\0') {
		errx(1, "N must be an int, got: %s", argv[1]);
	}

	if(N < 0) {
		errx(1, "N must be non-negative");
	}

	int D = strtol(argv[2], &endptr, 10);

	if(*argv[2] == '\0' || *endptr != '\0') {
		errx(1, "D must be an int, got: %s", argv[2]);
	}

	if(D < 0) {
		errx(1, "D must be non-negative");
	}

	int parent_to_child[2];
	if(pipe(parent_to_child) == -1) { err(1, "pipe"); }

	int child_to_parent[2];
	if(pipe(child_to_parent) == -1) { err(1, "pipe"); }

	pid_t pid = fork();
	if(pid == -1) { err(1, "fork"); }

	if(pid == 0) {
		// child
		close(parent_to_child[1]);
		close(child_to_parent[0]);
		
		handleChild(parent_to_child[0], child_to_parent[1]);

		close(parent_to_child[0]);
		close(child_to_parent[1]);

		exit(0);
	}

	// parent
	close(parent_to_child[0]);
	close(child_to_parent[1]);

	handleParent(N, D, parent_to_child[1], child_to_parent[0]);
	
	close(parent_to_child[1]);
	close(child_to_parent[0]);

	int status;
	if(wait(&status) == -1) { err(1, "wait"); }
	if(!WIFEXITED(status)) {
		errx(1, "child was killed");
	}

	return 0;
}

```

### –ó–∞–¥. 106 2023-IN-01

–í–∞—à–∏ –∫–æ–ª–µ–≥–∏ ‚Äì –∞—Å–∏—Å—Ç–µ–Ω—Ç–∏ –ø–æ –û–° ‚Äì –∏–º–∞—Ç –Ω—É–∂–¥–∞ –æ—Ç –¥–µ–º–æ—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–∞ –ø—Ä–æ–≥—Ä–∞–º–∞ –Ω–∞ C, –∫–æ—è—Ç–æ –¥–∞ —Å–ª—É–∂–∏ –∫–∞—Ç–æ
–ø—Ä–∏–º–µ—Ä –∑–∞ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ—Å—Ç –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–∞ –ø—Ä–æ—Ü–µ—Å–∏.

–î–µ—Ñ–∏–Ω–∏—Ä–∞–Ω –µ –Ω–∞—Ä–µ–¥–µ–Ω —Å–ø–∏—Å—ä–∫ —Å —Ç—Ä–∏ –¥—É–º–∏ ùêø = ("ùë°ùëñùëê " , "ùë°ùëéùëê " , "ùë°ùëúùëí\ùëõ"), –∫–∞—Ç–æ –≤—Å—è–∫–∞ –¥—É–º–∞ –µ —Å –¥—ä–ª–∂–∏–Ω–∞
—á–µ—Ç–∏—Ä–∏ –∑–Ω–∞–∫–∞. –ù–∞–ø–∏—à–µ—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–∞, –ø—Ä–∏–µ–º–∞—â–∞ –¥–≤–µ —á–∏—Å–ª–∞ –∫–∞—Ç–æ –∞—Ä–≥—É–º–µ–Ω—Ç–∏ (./main NC WC ), –∫–∞—Ç–æ ùëÅùê∂ –µ
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–æ –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ [1, 7], –∞ ùëäùê∂ ‚Äì –≤ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ [1, 35]. –ü—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ —Ç—Ä—è–±–≤–∞ –∑–∞–¥—ä–ª–∂–∏—Ç–µ–ª–Ω–æ –¥–∞ —Ä–∞–±–æ—Ç–∏
–ø–æ —Å–ª–µ–¥–Ω–∏—è –æ–±—â –∞–ª–≥–æ—Ä–∏—Ç—ä–º:
- –Ω–∞—á–∞–ª–Ω–∏—è—Ç (—Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏) –ø—Ä–æ—Ü–µ—Å —Å—ä–∑–¥–∞–≤–∞ ùëÅùê∂ –Ω–∞ –±—Ä–æ–π –ø—Ä–æ—Ü–µ—Å–∏-–Ω–∞—Å–ª–µ–¥–Ω–∏—Ü–∏;
- –≥—Ä—É–ø–∞—Ç–∞ –ø—Ä–æ—Ü–µ—Å–∏ –∏–∑–≤–µ–∂–¥–∞—Ç –Ω–∞ stdout –æ–±—â–æ ùëäùê∂ –Ω–∞ –±—Ä–æ–π –¥—É–º–∏ –æ—Ç –≥–æ—Ä–Ω–∏—è —Å–ø–∏—Å—ä–∫ –ø—Ä–∏ —Å–ª–µ–¥–Ω–∏—Ç–µ
–ø—Ä–∞–≤–∏–ª–∞:
* –∞–∫–æ –±—Ä–æ—è—Ç –Ω–∞ –¥—É–º–∏—Ç–µ –∑–∞ –∏–∑–≤–µ–∂–¥–∞–Ω–µ ùëäùê∂ –µ –ø–æ-–≥–æ–ª—è–º –æ—Ç –æ–±—â–∏—è –±—Ä–æ–π –¥—É–º–∏ –≤ ùêø, —Å–ª–µ–¥ –∏–∑—á–µ—Ä–ø–≤–∞–Ω–µ
–Ω–∞ –¥—É–º–∏—Ç–µ –≤ ùêø –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –∑–∞–ø–æ—á–≤–∞ —Å–ø–∏—Å—ä–∫–∞ –æ—Ç–Ω–∞—á–∞–ª–æ –∫–æ–ª–∫–æ—Ç–æ –ø—ä—Ç–∏ –µ –Ω—É–∂–Ω–æ;
* –≤—Å–µ–∫–∏ –ø—Ä–æ—Ü–µ—Å –∏–∑–≤–µ–∂–¥–∞ —Å–∞–º–æ –µ–¥–Ω–∞ –¥—É–º–∞;
* –ø—ä—Ä–≤–∞—Ç–∞ –¥—É–º–∞ —Å–µ –∏–∑–≤–µ–∂–¥–∞ –æ—Ç —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏—è –ø—Ä–æ—Ü–µ—Å;
* –∞–∫–æ –±—Ä–æ—è—Ç –Ω–∞ –¥—É–º–∏—Ç–µ –∑–∞ –∏–∑–≤–µ–∂–¥–∞–Ω–µ ùëäùê∂ –µ –ø–æ-–≥–æ–ª—è–º –æ—Ç –æ–±—â–∏—è –±—Ä–æ–π –ø—Ä–æ—Ü–µ—Å–∏, —Å–ª–µ–¥ –∏–∑—á–µ—Ä–ø–≤–∞–Ω–µ
–Ω–∞ –ø—Ä–æ—Ü–µ—Å–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞ –∑–∞–ø–æ—á–≤–∞ –¥–∞ –≥–∏ –ø–æ–ª–∑–≤–∞ –æ—Ç –Ω–∞—á–∞–ª–æ. –ù–∞–ø—Ä–∏–º–µ—Ä –ø—Ä–∏ —Ä–æ–¥–∏—Ç–µ–ª—Å–∫–∏ –ø—Ä–æ—Ü–µ—Å
ùëÉ –∏ –¥–≤–∞ –ø—Ä–æ—Ü–µ—Å–∞-–Ω–∞—Å–ª–µ–¥–Ω–∏—Ü–∏ ùê∂1 –∏ ùê∂2 —Ä–µ–¥—ä—Ç –Ω–∞ –∏–∑–ø–æ–ª–∑–≤–∞–Ω–µ –Ω–∞ –ø—Ä–æ—Ü–µ—Å–∏—Ç–µ —â–µ –±—ä–¥–µ ùëÉ, ùê∂1, ùê∂2,ùëÉ, ùê∂1, ùê∂2, ùëÉ, ùê∂1, ...
- –∏–∑–≤–µ–¥–µ–Ω–∏—Ç–µ –¥—É–º–∏ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞–Ω–æ —Ç—Ä—è–±–≤–∞ –¥–∞ —Å–∞ –ø–æ —Ä–µ–¥–∞, –¥–µ—Ñ–∏–Ω–∏—Ä–∞–Ω –≤ ùêø;
- –≤—Å–µ–∫–∏ –ø—Ä–æ—Ü–µ—Å –≥–∞—Ä–∞–Ω—Ç–∏—Ä–∞–Ω–æ –∑–∞–ø–æ—á–≤–∞ –¥–∞ –∏–∑–≤–µ–∂–¥–∞ –Ω–∞ stdout –ø–æ—Ä–µ–¥–Ω–∞—Ç–∞ –¥—É–º–∞, —Å–ª–µ–¥ –∫–∞—Ç–æ –ø—Ä–µ–¥—Ö–æ–¥–Ω–∏—è –ø—Ä–æ—Ü–µ—Å –µ –ø—Ä–∏–∫–ª—é—á–∏–ª —Å –∏–∑–≤–µ–∂–¥–∞–Ω–µ—Ç–æ –Ω–∞ –ø—Ä–µ–¥–∏—à–Ω–∞—Ç–∞.

–ó–∞–±–µ–ª–µ–∂–∫–∞: –ó–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–∞–Ω–µ –Ω–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∏—Ç–µ –ø–æ–≥–ª–µ–¥–Ω–µ—Ç–µ s t r t o l ( 3 ) .

```c
// #define DEBUG

#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <stdint.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <stdbool.h>

#ifdef DEBUG
#include <stdio.h>
#endif

const char* WORDS[] = {
	"tic ",
	"tac ",
	"toe\n"
};

void handleMessages(int, int, int);

void handleMessages(int totalWords, int fromFD, int toFD) {
	int count;
	ssize_t read_size;

	bool written_final_signal = false;

	while((read_size = read(fromFD, &count, sizeof(count))) > 0) {
		if(count >= totalWords) {
			if(!written_final_signal) {
				if(write(toFD, &count, sizeof(count)) == -1) { err(2, "write (finish)"); }
			}

			return;
		}

		if(write(1, WORDS[count % 3], strlen(WORDS[count % 3])) == -1) { err(2, "write (%d)", count); }

		int next = count + 1;
		if(write(toFD, &next, sizeof(next)) == -1) { err(2, "write (next)"); }

		// If this was the last message, make a note NOT to write it a second
		// time when the loop reaches this process again. Otherwise, the
		// process will die by SIGPIPE.
		if(next >= totalWords) {
			written_final_signal = true;
		}
	}

	// EOF is unexpected, we should be told we need to exit
	if(read_size == 0) {
		errx(2, "unexpected EOF");
	}

	if(read_size < 0) {
		err(2, "read");
	}
}

int main(int argc, char* argv[]) {
	if(argc != 3) {
		errx(1, "not enough args");
	}

	char* endptr;

	int children = strtol(argv[1], &endptr, 10);

	if(*argv[1] == '\0' || *endptr != '\0') {
		errx(1, "NC must be an int, got: %s", argv[1]);
	}

	if(children < 1 || children > 7) {
		errx(1, "NC must be between 1 and 7");
	}

	int totalWords = strtol(argv[2], &endptr, 10);

	if(*argv[1] == '\0' || *endptr != '\0') {
		errx(1, "WC must be an int, got: %s", argv[2]);
	}

	if(totalWords < 1 || totalWords > 35) {
		errx(1, "WC must be between 1 and 35");
	}

	int pipes = children + 1;

	int pipeFDs[8][2];
	for(int p = 0; p < pipes; p++) {
		if(pipe(pipeFDs[p]) == -1) { err(1, "pipe %d", p); }
	}
	
	for(int i = 1; i <= children; i++) {
		pid_t pid = fork();
		if(pid == -1) { err(1, "fork"); }

		if(pid == 0) {
			// child #i
			int fromFD = pipeFDs[i-1][0];
			int toFD = pipeFDs[i][1];

			for(int p = 0; p < pipes; p++) {
				if(pipeFDs[p][0] != fromFD){
					close(pipeFDs[p][0]);
				}
				if(pipeFDs[p][1] != toFD) {
					close(pipeFDs[p][1]);
				}
			}

			handleMessages(totalWords, fromFD, toFD);


			close(fromFD);
			close(toFD);

			exit(0);
		}


	}

	// parent
	int fromFD = pipeFDs[children][0];
	int toFD = pipeFDs[0][1];

	for(int p = 0; p < pipes; p++) {
		if(pipeFDs[p][0] != fromFD){
			close(pipeFDs[p][0]);
		}
		if(pipeFDs[p][1] != toFD) {
			close(pipeFDs[p][1]);
		}
	}


	if(write(1, WORDS[0], strlen(WORDS[0])) == -1) { err(1, "write (0)"); }

	int next = 1;
	if(write(toFD, &next, sizeof(next)) == -1) { err(2, "write (next)"); }

	handleMessages(totalWords, fromFD, toFD);

	close(fromFD);
	close(toFD);

	for(int i = 1; i <= children; i++) {
		pid_t pid;
		int status;
		if((pid = wait(&status)) == -1) { err(1, "wait"); }

		if (WIFEXITED(status)) {


			if(WEXITSTATUS(status) != 0) {
				warnx("child %d exited with code %d", pid, WEXITSTATUS(status));
			}
		} else {
			warnx("child %d was killed (%d)", pid, WIFSIGNALED(status) ? WTERMSIG(status) : 0);
		}
	}

	return 0;
}


```