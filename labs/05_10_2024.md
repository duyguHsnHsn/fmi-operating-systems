 # Notes from 10th of May
 
- Check for how to debug (after that the output should be removed)

### 2021-SE-02 

```c
#include <stdint.h>
#include <error.h>


uint8_t decode(uint8_t byte);

uint8_t decode(uint8_t byte){
    uint8_t result = 0;

    for(int = 0; i < 4; i++){
        int code = byte & 0x03; // to check it you can print the binary first 
        if ( code != 0x01 && code != 0x02) { errx(5, "bad encoding") }
        if (code != 0x01)  {  
            result |= 1 << i;
        }

    }

    return result;
}



int main(int argc, char* argv[]){
    if (argc != 3){
        errx(1, "wrogn number of args")
    }

    int in = open(argv[1], O_RDONLY);

    if (in == -1){
        err(1, "%s", argv[1]);
    }


    int out = open(argv[2], O_WRONLY | O_TRUNC | O_CREAT , S_TRUSH | S_TWUSR);
    if (out == -1){
        err(1, "%s", argv[2]);
    }

    uint8_t encoded_bytes[2];
    ssize_t read_size;

    while ((read_size = read(in, &encoded_bytes, sizeof(encoded_bytes))) > 0){
        uint8_t result = (decode(encoded_bytes[0]) << 4) |  decode(encoded_bytes[1]);
        if(write(out))
        // need to add the rest



    }

    if (read_size == -1){
            err(4, "can't read")
        }
    
    close(in);
    close(out);

    return 0;

```

### Зад. 92 2023-SE-01

```c
#include <stdint.h>
#include <stdbool.h>
#include <error.h>


bool readByte(int fd);
void tryMessage(int in, int out);

// Returns: true if byte was read
bool readByte(int fd, uint8_t* result){
    ssize_t read_size;
    if ((read_size = read(fd, result, sizeof(uint8_t))) == -1 ){
            err(4, "can't read");
    }

    return (result != 0) ;
}

void tryMessage(int in, int out, off_t offset) {
    uint8_t cehcksum = 0x55;

    uint8_t N;
    if(!readByte(in, &N)) {
        return;
    }

    checksum ^= N;

    for( int i = 3; i <= N -1; i++){
        if(!readByte(in, &N)) {
            return;
        }
        checksum ^= byte;

        uint8_t expectedChecksum;
        if(!readByte(in, &expectedChecksum)){
            return
        }

        if (cehcksum != expectedChecksum){
            return;
        }

        //message is valid 
        uint8_t byte = 0x55;
        if(write(out, &byte, sizeof(byte)) == -1) {err(5, "can't write");}
        if (lseek(in, offset, SEEK_SET) == -1 ) { err(2, "can't lseek"); }
        for(int = 2; i <= N; i++){
            

        }

    }
    
}


int main(int argc, char* argv[]){
    if (argc != 3){
        errx(1, "wrogn number of args");
    }

    int in = open(argv[1], O_RDONLY);
    if (in == -1){
        err(1, "%s", argv[1]);
    }

    int out = open(argv[2], O_WRONLY | O_TRUNC | O_CREAT , S_TRUSH | S_TWUSR);
    if (out == -1){
        err(1, "%s", argv[2]);
    }

    uint8_t byte;
    ssize_t read_size;

    while(readByte(in, &byte)){
        if(byte == 0x55){
            off_t current_offset = lseek(in, 0, SEEK_CUR);
            if (current_offset == -1) { err(2, "can't lseek"); }
            // check message
            tryMessage(in, out, current_offset);

            if (lseek(in, current_offset, SEEK_SET) == -1 ) { err(2, "can't lseek"); }
        }
    }
    
    close(in);
    close(out);

    return 0;

```

